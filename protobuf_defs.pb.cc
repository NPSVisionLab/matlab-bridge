// Generated by the protocol buffer compiler.  DO NOT EDIT!

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "algorithms/matlab_bridge/protobuf_defs.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* MatlabBridgeMsg_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  MatlabBridgeMsg_reflection_ = NULL;
const ::google::protobuf::Descriptor* Model_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Model_reflection_ = NULL;
const ::google::protobuf::Descriptor* ServiceDefinition_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ServiceDefinition_reflection_ = NULL;
const ::google::protobuf::Descriptor* Result_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Result_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResultList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResultList_reflection_ = NULL;
const ::google::protobuf::Descriptor* ResultSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ResultSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* DirectoryPath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  DirectoryPath_reflection_ = NULL;
const ::google::protobuf::Descriptor* FilePath_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FilePath_reflection_ = NULL;
const ::google::protobuf::Descriptor* Substrate_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Substrate_reflection_ = NULL;
const ::google::protobuf::Descriptor* Semantics_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Semantics_reflection_ = NULL;
const ::google::protobuf::Descriptor* LabelProperties_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LabelProperties_reflection_ = NULL;
const ::google::protobuf::Descriptor* Label_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Label_reflection_ = NULL;
const ::google::protobuf::Descriptor* Labelable_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Labelable_reflection_ = NULL;
const ::google::protobuf::Descriptor* LabelableList_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LabelableList_reflection_ = NULL;
const ::google::protobuf::Descriptor* Purpose_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Purpose_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* Purpose_PurposeType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* PurposedLabelableSeq_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PurposedLabelableSeq_reflection_ = NULL;
const ::google::protobuf::Descriptor* PurposedListSequence_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PurposedListSequence_reflection_ = NULL;
const ::google::protobuf::Descriptor* RunSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  RunSet_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto() {
  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "algorithms/matlab_bridge/protobuf_defs.proto");
  GOOGLE_CHECK(file != NULL);
  MatlabBridgeMsg_descriptor_ = file->message_type(0);
  static const int MatlabBridgeMsg_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatlabBridgeMsg, run_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatlabBridgeMsg, servicedef_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatlabBridgeMsg, res_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatlabBridgeMsg, model_),
  };
  MatlabBridgeMsg_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      MatlabBridgeMsg_descriptor_,
      MatlabBridgeMsg::default_instance_,
      MatlabBridgeMsg_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatlabBridgeMsg, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(MatlabBridgeMsg, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(MatlabBridgeMsg));
  Model_descriptor_ = file->message_type(1);
  static const int Model_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, mpath_),
  };
  Model_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Model_descriptor_,
      Model::default_instance_,
      Model_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Model, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Model));
  ServiceDefinition_descriptor_ = file->message_type(2);
  static const int ServiceDefinition_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceDefinition, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceDefinition, value_),
  };
  ServiceDefinition_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ServiceDefinition_descriptor_,
      ServiceDefinition::default_instance_,
      ServiceDefinition_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceDefinition, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ServiceDefinition, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ServiceDefinition));
  Result_descriptor_ = file->message_type(3);
  static const int Result_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, original_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, foundlabels_),
  };
  Result_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Result_descriptor_,
      Result::default_instance_,
      Result_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Result, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Result));
  ResultList_descriptor_ = file->message_type(4);
  static const int ResultList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResultList, rslt_),
  };
  ResultList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResultList_descriptor_,
      ResultList::default_instance_,
      ResultList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResultList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResultList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResultList));
  ResultSet_descriptor_ = file->message_type(5);
  static const int ResultSet_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResultSet, results_),
  };
  ResultSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ResultSet_descriptor_,
      ResultSet::default_instance_,
      ResultSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResultSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ResultSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ResultSet));
  DirectoryPath_descriptor_ = file->message_type(6);
  static const int DirectoryPath_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryPath, relativepath_),
  };
  DirectoryPath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      DirectoryPath_descriptor_,
      DirectoryPath::default_instance_,
      DirectoryPath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryPath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(DirectoryPath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(DirectoryPath));
  FilePath_descriptor_ = file->message_type(7);
  static const int FilePath_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilePath, directory_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilePath, filename_),
  };
  FilePath_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FilePath_descriptor_,
      FilePath::default_instance_,
      FilePath_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilePath, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FilePath, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FilePath));
  Substrate_descriptor_ = file->message_type(8);
  static const int Substrate_offsets_[5] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, isimage_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, isvideo_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, path_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, height_),
  };
  Substrate_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Substrate_descriptor_,
      Substrate::default_instance_,
      Substrate_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Substrate, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Substrate));
  Semantics_descriptor_ = file->message_type(9);
  static const int Semantics_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Semantics, url_),
  };
  Semantics_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Semantics_descriptor_,
      Semantics::default_instance_,
      Semantics_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Semantics, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Semantics, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Semantics));
  LabelProperties_descriptor_ = file->message_type(10);
  static const int LabelProperties_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelProperties, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelProperties, value_),
  };
  LabelProperties_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LabelProperties_descriptor_,
      LabelProperties::default_instance_,
      LabelProperties_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelProperties, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelProperties, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LabelProperties));
  Label_descriptor_ = file->message_type(11);
  static const int Label_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, haslabel_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, properties_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, semantix_),
  };
  Label_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Label_descriptor_,
      Label::default_instance_,
      Label_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Label, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Label));
  Labelable_descriptor_ = file->message_type(12);
  static const int Labelable_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labelable, confidence_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labelable, lab_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labelable, sub_),
  };
  Labelable_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Labelable_descriptor_,
      Labelable::default_instance_,
      Labelable_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labelable, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Labelable, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Labelable));
  LabelableList_descriptor_ = file->message_type(13);
  static const int LabelableList_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelableList, labelable_),
  };
  LabelableList_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LabelableList_descriptor_,
      LabelableList::default_instance_,
      LabelableList_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelableList, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LabelableList, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LabelableList));
  Purpose_descriptor_ = file->message_type(14);
  static const int Purpose_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Purpose, ptype_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Purpose, classid_),
  };
  Purpose_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Purpose_descriptor_,
      Purpose::default_instance_,
      Purpose_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Purpose, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Purpose, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Purpose));
  Purpose_PurposeType_descriptor_ = Purpose_descriptor_->enum_type(0);
  PurposedLabelableSeq_descriptor_ = file->message_type(15);
  static const int PurposedLabelableSeq_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedLabelableSeq, pur_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedLabelableSeq, labeledartifacts_),
  };
  PurposedLabelableSeq_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PurposedLabelableSeq_descriptor_,
      PurposedLabelableSeq::default_instance_,
      PurposedLabelableSeq_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedLabelableSeq, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedLabelableSeq, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PurposedLabelableSeq));
  PurposedListSequence_descriptor_ = file->message_type(16);
  static const int PurposedListSequence_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedListSequence, purlist_),
  };
  PurposedListSequence_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PurposedListSequence_descriptor_,
      PurposedListSequence::default_instance_,
      PurposedListSequence_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedListSequence, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PurposedListSequence, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PurposedListSequence));
  RunSet_descriptor_ = file->message_type(17);
  static const int RunSet_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunSet, purposedlists_),
  };
  RunSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      RunSet_descriptor_,
      RunSet::default_instance_,
      RunSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(RunSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(RunSet));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    MatlabBridgeMsg_descriptor_, &MatlabBridgeMsg::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Model_descriptor_, &Model::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ServiceDefinition_descriptor_, &ServiceDefinition::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Result_descriptor_, &Result::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResultList_descriptor_, &ResultList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ResultSet_descriptor_, &ResultSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    DirectoryPath_descriptor_, &DirectoryPath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FilePath_descriptor_, &FilePath::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Substrate_descriptor_, &Substrate::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Semantics_descriptor_, &Semantics::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LabelProperties_descriptor_, &LabelProperties::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Label_descriptor_, &Label::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Labelable_descriptor_, &Labelable::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LabelableList_descriptor_, &LabelableList::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Purpose_descriptor_, &Purpose::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PurposedLabelableSeq_descriptor_, &PurposedLabelableSeq::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PurposedListSequence_descriptor_, &PurposedListSequence::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    RunSet_descriptor_, &RunSet::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto() {
  delete MatlabBridgeMsg::default_instance_;
  delete MatlabBridgeMsg_reflection_;
  delete Model::default_instance_;
  delete Model_reflection_;
  delete ServiceDefinition::default_instance_;
  delete ServiceDefinition_reflection_;
  delete Result::default_instance_;
  delete Result_reflection_;
  delete ResultList::default_instance_;
  delete ResultList_reflection_;
  delete ResultSet::default_instance_;
  delete ResultSet_reflection_;
  delete DirectoryPath::default_instance_;
  delete DirectoryPath_reflection_;
  delete FilePath::default_instance_;
  delete FilePath_reflection_;
  delete Substrate::default_instance_;
  delete Substrate_reflection_;
  delete Semantics::default_instance_;
  delete Semantics_reflection_;
  delete LabelProperties::default_instance_;
  delete LabelProperties_reflection_;
  delete Label::default_instance_;
  delete Label_reflection_;
  delete Labelable::default_instance_;
  delete Labelable_reflection_;
  delete LabelableList::default_instance_;
  delete LabelableList_reflection_;
  delete Purpose::default_instance_;
  delete Purpose_reflection_;
  delete PurposedLabelableSeq::default_instance_;
  delete PurposedLabelableSeq_reflection_;
  delete PurposedListSequence::default_instance_;
  delete PurposedListSequence_reflection_;
  delete RunSet::default_instance_;
  delete RunSet_reflection_;
}

void protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n,algorithms/matlab_bridge/protobuf_defs"
    ".proto\"\177\n\017MatlabBridgeMsg\022\024\n\003run\030\001 \001(\0132\007"
    ".RunSet\022&\n\nserviceDef\030\002 \003(\0132\022.ServiceDef"
    "inition\022\027\n\003res\030\003 \001(\0132\n.ResultSet\022\025\n\005mode"
    "l\030\004 \001(\0132\006.Model\"!\n\005Model\022\030\n\005mPath\030\001 \001(\0132"
    "\t.FilePath\"3\n\021ServiceDefinition\022\r\n\003key\030\001"
    " \001(\t:\000\022\017\n\005value\030\002 \001(\t:\000\"K\n\006Result\022\034\n\010ori"
    "ginal\030\001 \001(\0132\n.Labelable\022#\n\013foundLabels\030\002"
    " \001(\0132\016.LabelableList\"#\n\nResultList\022\025\n\004rs"
    "lt\030\001 \003(\0132\007.Result\")\n\tResultSet\022\034\n\007result"
    "s\030\001 \001(\0132\013.ResultList\"\'\n\rDirectoryPath\022\026\n"
    "\014relativePath\030\001 \001(\t:\000\"A\n\010FilePath\022!\n\tdir"
    "ectory\030\001 \001(\0132\016.DirectoryPath\022\022\n\010filename"
    "\030\002 \001(\t:\000\"x\n\tSubstrate\022\025\n\007isImage\030\001 \001(\010:\004"
    "true\022\026\n\007isVideo\030\002 \001(\010:\005false\022\027\n\004path\030\003 \001"
    "(\0132\t.FilePath\022\020\n\005width\030\004 \001(\005:\0010\022\021\n\006heigh"
    "t\030\005 \001(\005:\0010\"\032\n\tSemantics\022\r\n\003url\030\001 \001(\t:\000\"1"
    "\n\017LabelProperties\022\r\n\003key\030\001 \001(\t:\000\022\017\n\005valu"
    "e\030\002 \001(\t:\000\"t\n\005Label\022\027\n\010hasLabel\030\001 \001(\010:\005fa"
    "lse\022\016\n\004name\030\002 \001(\t:\000\022$\n\nproperties\030\003 \001(\0132"
    "\020.LabelProperties\022\034\n\010semantix\030\004 \001(\0132\n.Se"
    "mantics\"P\n\tLabelable\022\025\n\nconfidence\030\001 \001(\002"
    ":\0010\022\023\n\003lab\030\002 \001(\0132\006.Label\022\027\n\003sub\030\003 \001(\0132\n."
    "Substrate\".\n\rLabelableList\022\035\n\tlabelable\030"
    "\001 \003(\0132\n.Labelable\"\242\001\n\007Purpose\022/\n\005ptype\030\001"
    " \001(\0162\024.Purpose.PurposeType:\nUNPURPOSED\022\022"
    "\n\007classID\030\002 \001(\005:\0010\"R\n\013PurposeType\022\016\n\nUNP"
    "URPOSED\020\000\022\014\n\010POSITIVE\020\001\022\014\n\010NEGATIVE\020\002\022\016\n"
    "\nMULTICLASS\020\003\022\007\n\003ANY\020\004\"W\n\024PurposedLabela"
    "bleSeq\022\025\n\003pur\030\001 \001(\0132\010.Purpose\022(\n\020labeled"
    "Artifacts\030\002 \001(\0132\016.LabelableList\">\n\024Purpo"
    "sedListSequence\022&\n\007purlist\030\001 \003(\0132\025.Purpo"
    "sedLabelableSeq\"6\n\006RunSet\022,\n\rpurposedLis"
    "ts\030\001 \001(\0132\025.PurposedListSequence", 1351);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "algorithms/matlab_bridge/protobuf_defs.proto", &protobuf_RegisterTypes);
  MatlabBridgeMsg::default_instance_ = new MatlabBridgeMsg();
  Model::default_instance_ = new Model();
  ServiceDefinition::default_instance_ = new ServiceDefinition();
  Result::default_instance_ = new Result();
  ResultList::default_instance_ = new ResultList();
  ResultSet::default_instance_ = new ResultSet();
  DirectoryPath::default_instance_ = new DirectoryPath();
  FilePath::default_instance_ = new FilePath();
  Substrate::default_instance_ = new Substrate();
  Semantics::default_instance_ = new Semantics();
  LabelProperties::default_instance_ = new LabelProperties();
  Label::default_instance_ = new Label();
  Labelable::default_instance_ = new Labelable();
  LabelableList::default_instance_ = new LabelableList();
  Purpose::default_instance_ = new Purpose();
  PurposedLabelableSeq::default_instance_ = new PurposedLabelableSeq();
  PurposedListSequence::default_instance_ = new PurposedListSequence();
  RunSet::default_instance_ = new RunSet();
  MatlabBridgeMsg::default_instance_->InitAsDefaultInstance();
  Model::default_instance_->InitAsDefaultInstance();
  ServiceDefinition::default_instance_->InitAsDefaultInstance();
  Result::default_instance_->InitAsDefaultInstance();
  ResultList::default_instance_->InitAsDefaultInstance();
  ResultSet::default_instance_->InitAsDefaultInstance();
  DirectoryPath::default_instance_->InitAsDefaultInstance();
  FilePath::default_instance_->InitAsDefaultInstance();
  Substrate::default_instance_->InitAsDefaultInstance();
  Semantics::default_instance_->InitAsDefaultInstance();
  LabelProperties::default_instance_->InitAsDefaultInstance();
  Label::default_instance_->InitAsDefaultInstance();
  Labelable::default_instance_->InitAsDefaultInstance();
  LabelableList::default_instance_->InitAsDefaultInstance();
  Purpose::default_instance_->InitAsDefaultInstance();
  PurposedLabelableSeq::default_instance_->InitAsDefaultInstance();
  PurposedListSequence::default_instance_->InitAsDefaultInstance();
  RunSet::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto {
  StaticDescriptorInitializer_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto() {
    protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  }
} static_descriptor_initializer_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto_;


// ===================================================================

#ifndef _MSC_VER
const int MatlabBridgeMsg::kRunFieldNumber;
const int MatlabBridgeMsg::kServiceDefFieldNumber;
const int MatlabBridgeMsg::kResFieldNumber;
const int MatlabBridgeMsg::kModelFieldNumber;
#endif  // !_MSC_VER

MatlabBridgeMsg::MatlabBridgeMsg()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void MatlabBridgeMsg::InitAsDefaultInstance() {
  run_ = const_cast< ::RunSet*>(&::RunSet::default_instance());
  res_ = const_cast< ::ResultSet*>(&::ResultSet::default_instance());
  model_ = const_cast< ::Model*>(&::Model::default_instance());
}

MatlabBridgeMsg::MatlabBridgeMsg(const MatlabBridgeMsg& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void MatlabBridgeMsg::SharedCtor() {
  _cached_size_ = 0;
  run_ = NULL;
  res_ = NULL;
  model_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

MatlabBridgeMsg::~MatlabBridgeMsg() {
  SharedDtor();
}

void MatlabBridgeMsg::SharedDtor() {
  if (this != default_instance_) {
    delete run_;
    delete res_;
    delete model_;
  }
}

void MatlabBridgeMsg::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* MatlabBridgeMsg::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return MatlabBridgeMsg_descriptor_;
}

const MatlabBridgeMsg& MatlabBridgeMsg::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

MatlabBridgeMsg* MatlabBridgeMsg::default_instance_ = NULL;

MatlabBridgeMsg* MatlabBridgeMsg::New() const {
  return new MatlabBridgeMsg;
}

void MatlabBridgeMsg::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_run()) {
      if (run_ != NULL) run_->::RunSet::Clear();
    }
    if (has_res()) {
      if (res_ != NULL) res_->::ResultSet::Clear();
    }
    if (has_model()) {
      if (model_ != NULL) model_->::Model::Clear();
    }
  }
  servicedef_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool MatlabBridgeMsg::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .RunSet run = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_run()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serviceDef;
        break;
      }
      
      // repeated .ServiceDefinition serviceDef = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_serviceDef:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_servicedef()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_serviceDef;
        if (input->ExpectTag(26)) goto parse_res;
        break;
      }
      
      // optional .ResultSet res = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_res:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_res()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_model;
        break;
      }
      
      // optional .Model model = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_model:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_model()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void MatlabBridgeMsg::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .RunSet run = 1;
  if (has_run()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->run(), output);
  }
  
  // repeated .ServiceDefinition serviceDef = 2;
  for (int i = 0; i < this->servicedef_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->servicedef(i), output);
  }
  
  // optional .ResultSet res = 3;
  if (has_res()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->res(), output);
  }
  
  // optional .Model model = 4;
  if (has_model()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->model(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* MatlabBridgeMsg::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .RunSet run = 1;
  if (has_run()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->run(), target);
  }
  
  // repeated .ServiceDefinition serviceDef = 2;
  for (int i = 0; i < this->servicedef_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->servicedef(i), target);
  }
  
  // optional .ResultSet res = 3;
  if (has_res()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->res(), target);
  }
  
  // optional .Model model = 4;
  if (has_model()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->model(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int MatlabBridgeMsg::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .RunSet run = 1;
    if (has_run()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->run());
    }
    
    // optional .ResultSet res = 3;
    if (has_res()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->res());
    }
    
    // optional .Model model = 4;
    if (has_model()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->model());
    }
    
  }
  // repeated .ServiceDefinition serviceDef = 2;
  total_size += 1 * this->servicedef_size();
  for (int i = 0; i < this->servicedef_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->servicedef(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void MatlabBridgeMsg::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const MatlabBridgeMsg* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const MatlabBridgeMsg*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void MatlabBridgeMsg::MergeFrom(const MatlabBridgeMsg& from) {
  GOOGLE_CHECK_NE(&from, this);
  servicedef_.MergeFrom(from.servicedef_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_run()) {
      mutable_run()->::RunSet::MergeFrom(from.run());
    }
    if (from.has_res()) {
      mutable_res()->::ResultSet::MergeFrom(from.res());
    }
    if (from.has_model()) {
      mutable_model()->::Model::MergeFrom(from.model());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void MatlabBridgeMsg::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void MatlabBridgeMsg::CopyFrom(const MatlabBridgeMsg& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool MatlabBridgeMsg::IsInitialized() const {
  
  return true;
}

void MatlabBridgeMsg::Swap(MatlabBridgeMsg* other) {
  if (other != this) {
    std::swap(run_, other->run_);
    servicedef_.Swap(&other->servicedef_);
    std::swap(res_, other->res_);
    std::swap(model_, other->model_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata MatlabBridgeMsg::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = MatlabBridgeMsg_descriptor_;
  metadata.reflection = MatlabBridgeMsg_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Model::kMPathFieldNumber;
#endif  // !_MSC_VER

Model::Model()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Model::InitAsDefaultInstance() {
  mpath_ = const_cast< ::FilePath*>(&::FilePath::default_instance());
}

Model::Model(const Model& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Model::SharedCtor() {
  _cached_size_ = 0;
  mpath_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Model::~Model() {
  SharedDtor();
}

void Model::SharedDtor() {
  if (this != default_instance_) {
    delete mpath_;
  }
}

void Model::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Model::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Model_descriptor_;
}

const Model& Model::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Model* Model::default_instance_ = NULL;

Model* Model::New() const {
  return new Model;
}

void Model::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_mpath()) {
      if (mpath_ != NULL) mpath_->::FilePath::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Model::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .FilePath mPath = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_mpath()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Model::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .FilePath mPath = 1;
  if (has_mpath()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->mpath(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Model::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .FilePath mPath = 1;
  if (has_mpath()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->mpath(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Model::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .FilePath mPath = 1;
    if (has_mpath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->mpath());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Model::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Model* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Model*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Model::MergeFrom(const Model& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_mpath()) {
      mutable_mpath()->::FilePath::MergeFrom(from.mpath());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Model::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Model::CopyFrom(const Model& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Model::IsInitialized() const {
  
  return true;
}

void Model::Swap(Model* other) {
  if (other != this) {
    std::swap(mpath_, other->mpath_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Model::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Model_descriptor_;
  metadata.reflection = Model_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ServiceDefinition::kKeyFieldNumber;
const int ServiceDefinition::kValueFieldNumber;
#endif  // !_MSC_VER

ServiceDefinition::ServiceDefinition()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ServiceDefinition::InitAsDefaultInstance() {
}

ServiceDefinition::ServiceDefinition(const ServiceDefinition& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ServiceDefinition::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ServiceDefinition::~ServiceDefinition() {
  SharedDtor();
}

void ServiceDefinition::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void ServiceDefinition::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ServiceDefinition::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ServiceDefinition_descriptor_;
}

const ServiceDefinition& ServiceDefinition::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

ServiceDefinition* ServiceDefinition::default_instance_ = NULL;

ServiceDefinition* ServiceDefinition::New() const {
  return new ServiceDefinition;
}

void ServiceDefinition::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ServiceDefinition::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1 [default = ""];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }
      
      // optional string value = 2 [default = ""];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ServiceDefinition::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1 [default = ""];
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  // optional string value = 2 [default = ""];
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ServiceDefinition::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1 [default = ""];
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  // optional string value = 2 [default = ""];
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ServiceDefinition::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1 [default = ""];
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // optional string value = 2 [default = ""];
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ServiceDefinition::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ServiceDefinition* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ServiceDefinition*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ServiceDefinition::MergeFrom(const ServiceDefinition& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ServiceDefinition::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ServiceDefinition::CopyFrom(const ServiceDefinition& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ServiceDefinition::IsInitialized() const {
  
  return true;
}

void ServiceDefinition::Swap(ServiceDefinition* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ServiceDefinition::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ServiceDefinition_descriptor_;
  metadata.reflection = ServiceDefinition_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Result::kOriginalFieldNumber;
const int Result::kFoundLabelsFieldNumber;
#endif  // !_MSC_VER

Result::Result()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Result::InitAsDefaultInstance() {
  original_ = const_cast< ::Labelable*>(&::Labelable::default_instance());
  foundlabels_ = const_cast< ::LabelableList*>(&::LabelableList::default_instance());
}

Result::Result(const Result& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Result::SharedCtor() {
  _cached_size_ = 0;
  original_ = NULL;
  foundlabels_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Result::~Result() {
  SharedDtor();
}

void Result::SharedDtor() {
  if (this != default_instance_) {
    delete original_;
    delete foundlabels_;
  }
}

void Result::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Result::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Result_descriptor_;
}

const Result& Result::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Result* Result::default_instance_ = NULL;

Result* Result::New() const {
  return new Result;
}

void Result::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_original()) {
      if (original_ != NULL) original_->::Labelable::Clear();
    }
    if (has_foundlabels()) {
      if (foundlabels_ != NULL) foundlabels_->::LabelableList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Result::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Labelable original = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_original()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_foundLabels;
        break;
      }
      
      // optional .LabelableList foundLabels = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_foundLabels:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_foundlabels()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Result::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Labelable original = 1;
  if (has_original()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->original(), output);
  }
  
  // optional .LabelableList foundLabels = 2;
  if (has_foundlabels()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->foundlabels(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Result::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Labelable original = 1;
  if (has_original()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->original(), target);
  }
  
  // optional .LabelableList foundLabels = 2;
  if (has_foundlabels()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->foundlabels(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Result::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Labelable original = 1;
    if (has_original()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->original());
    }
    
    // optional .LabelableList foundLabels = 2;
    if (has_foundlabels()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->foundlabels());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Result::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Result* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Result*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Result::MergeFrom(const Result& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_original()) {
      mutable_original()->::Labelable::MergeFrom(from.original());
    }
    if (from.has_foundlabels()) {
      mutable_foundlabels()->::LabelableList::MergeFrom(from.foundlabels());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Result::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Result::CopyFrom(const Result& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Result::IsInitialized() const {
  
  return true;
}

void Result::Swap(Result* other) {
  if (other != this) {
    std::swap(original_, other->original_);
    std::swap(foundlabels_, other->foundlabels_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Result::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Result_descriptor_;
  metadata.reflection = Result_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResultList::kRsltFieldNumber;
#endif  // !_MSC_VER

ResultList::ResultList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResultList::InitAsDefaultInstance() {
}

ResultList::ResultList(const ResultList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResultList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResultList::~ResultList() {
  SharedDtor();
}

void ResultList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ResultList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResultList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResultList_descriptor_;
}

const ResultList& ResultList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

ResultList* ResultList::default_instance_ = NULL;

ResultList* ResultList::New() const {
  return new ResultList;
}

void ResultList::Clear() {
  rslt_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResultList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Result rslt = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_rslt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_rslt()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_rslt;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResultList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Result rslt = 1;
  for (int i = 0; i < this->rslt_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->rslt(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResultList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Result rslt = 1;
  for (int i = 0; i < this->rslt_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->rslt(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResultList::ByteSize() const {
  int total_size = 0;
  
  // repeated .Result rslt = 1;
  total_size += 1 * this->rslt_size();
  for (int i = 0; i < this->rslt_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->rslt(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResultList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResultList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResultList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResultList::MergeFrom(const ResultList& from) {
  GOOGLE_CHECK_NE(&from, this);
  rslt_.MergeFrom(from.rslt_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResultList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResultList::CopyFrom(const ResultList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResultList::IsInitialized() const {
  
  return true;
}

void ResultList::Swap(ResultList* other) {
  if (other != this) {
    rslt_.Swap(&other->rslt_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResultList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResultList_descriptor_;
  metadata.reflection = ResultList_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ResultSet::kResultsFieldNumber;
#endif  // !_MSC_VER

ResultSet::ResultSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ResultSet::InitAsDefaultInstance() {
  results_ = const_cast< ::ResultList*>(&::ResultList::default_instance());
}

ResultSet::ResultSet(const ResultSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ResultSet::SharedCtor() {
  _cached_size_ = 0;
  results_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ResultSet::~ResultSet() {
  SharedDtor();
}

void ResultSet::SharedDtor() {
  if (this != default_instance_) {
    delete results_;
  }
}

void ResultSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ResultSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ResultSet_descriptor_;
}

const ResultSet& ResultSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

ResultSet* ResultSet::default_instance_ = NULL;

ResultSet* ResultSet::New() const {
  return new ResultSet;
}

void ResultSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_results()) {
      if (results_ != NULL) results_->::ResultList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ResultSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .ResultList results = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_results()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ResultSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .ResultList results = 1;
  if (has_results()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->results(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ResultSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .ResultList results = 1;
  if (has_results()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->results(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ResultSet::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .ResultList results = 1;
    if (has_results()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->results());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ResultSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ResultSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ResultSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ResultSet::MergeFrom(const ResultSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_results()) {
      mutable_results()->::ResultList::MergeFrom(from.results());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ResultSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ResultSet::CopyFrom(const ResultSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ResultSet::IsInitialized() const {
  
  return true;
}

void ResultSet::Swap(ResultSet* other) {
  if (other != this) {
    std::swap(results_, other->results_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ResultSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ResultSet_descriptor_;
  metadata.reflection = ResultSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int DirectoryPath::kRelativePathFieldNumber;
#endif  // !_MSC_VER

DirectoryPath::DirectoryPath()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void DirectoryPath::InitAsDefaultInstance() {
}

DirectoryPath::DirectoryPath(const DirectoryPath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void DirectoryPath::SharedCtor() {
  _cached_size_ = 0;
  relativepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

DirectoryPath::~DirectoryPath() {
  SharedDtor();
}

void DirectoryPath::SharedDtor() {
  if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
    delete relativepath_;
  }
  if (this != default_instance_) {
  }
}

void DirectoryPath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* DirectoryPath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return DirectoryPath_descriptor_;
}

const DirectoryPath& DirectoryPath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

DirectoryPath* DirectoryPath::default_instance_ = NULL;

DirectoryPath* DirectoryPath::New() const {
  return new DirectoryPath;
}

void DirectoryPath::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_relativepath()) {
      if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
        relativepath_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool DirectoryPath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string relativePath = 1 [default = ""];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_relativepath()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->relativepath().data(), this->relativepath().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void DirectoryPath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string relativePath = 1 [default = ""];
  if (has_relativepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->relativepath().data(), this->relativepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->relativepath(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* DirectoryPath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string relativePath = 1 [default = ""];
  if (has_relativepath()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->relativepath().data(), this->relativepath().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->relativepath(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int DirectoryPath::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string relativePath = 1 [default = ""];
    if (has_relativepath()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->relativepath());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void DirectoryPath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const DirectoryPath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const DirectoryPath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void DirectoryPath::MergeFrom(const DirectoryPath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_relativepath()) {
      set_relativepath(from.relativepath());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void DirectoryPath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void DirectoryPath::CopyFrom(const DirectoryPath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DirectoryPath::IsInitialized() const {
  
  return true;
}

void DirectoryPath::Swap(DirectoryPath* other) {
  if (other != this) {
    std::swap(relativepath_, other->relativepath_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata DirectoryPath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = DirectoryPath_descriptor_;
  metadata.reflection = DirectoryPath_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FilePath::kDirectoryFieldNumber;
const int FilePath::kFilenameFieldNumber;
#endif  // !_MSC_VER

FilePath::FilePath()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FilePath::InitAsDefaultInstance() {
  directory_ = const_cast< ::DirectoryPath*>(&::DirectoryPath::default_instance());
}

FilePath::FilePath(const FilePath& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FilePath::SharedCtor() {
  _cached_size_ = 0;
  directory_ = NULL;
  filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FilePath::~FilePath() {
  SharedDtor();
}

void FilePath::SharedDtor() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (this != default_instance_) {
    delete directory_;
  }
}

void FilePath::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FilePath::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FilePath_descriptor_;
}

const FilePath& FilePath::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

FilePath* FilePath::default_instance_ = NULL;

FilePath* FilePath::New() const {
  return new FilePath;
}

void FilePath::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_directory()) {
      if (directory_ != NULL) directory_->::DirectoryPath::Clear();
    }
    if (has_filename()) {
      if (filename_ != &::google::protobuf::internal::kEmptyString) {
        filename_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FilePath::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .DirectoryPath directory = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_directory()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_filename;
        break;
      }
      
      // optional string filename = 2 [default = ""];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_filename:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_filename()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->filename().data(), this->filename().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FilePath::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .DirectoryPath directory = 1;
  if (has_directory()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->directory(), output);
  }
  
  // optional string filename = 2 [default = ""];
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->filename(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FilePath::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .DirectoryPath directory = 1;
  if (has_directory()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->directory(), target);
  }
  
  // optional string filename = 2 [default = ""];
  if (has_filename()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->filename().data(), this->filename().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->filename(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FilePath::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .DirectoryPath directory = 1;
    if (has_directory()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->directory());
    }
    
    // optional string filename = 2 [default = ""];
    if (has_filename()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->filename());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FilePath::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FilePath* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FilePath*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FilePath::MergeFrom(const FilePath& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_directory()) {
      mutable_directory()->::DirectoryPath::MergeFrom(from.directory());
    }
    if (from.has_filename()) {
      set_filename(from.filename());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FilePath::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FilePath::CopyFrom(const FilePath& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FilePath::IsInitialized() const {
  
  return true;
}

void FilePath::Swap(FilePath* other) {
  if (other != this) {
    std::swap(directory_, other->directory_);
    std::swap(filename_, other->filename_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FilePath::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FilePath_descriptor_;
  metadata.reflection = FilePath_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Substrate::kIsImageFieldNumber;
const int Substrate::kIsVideoFieldNumber;
const int Substrate::kPathFieldNumber;
const int Substrate::kWidthFieldNumber;
const int Substrate::kHeightFieldNumber;
#endif  // !_MSC_VER

Substrate::Substrate()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Substrate::InitAsDefaultInstance() {
  path_ = const_cast< ::FilePath*>(&::FilePath::default_instance());
}

Substrate::Substrate(const Substrate& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Substrate::SharedCtor() {
  _cached_size_ = 0;
  isimage_ = true;
  isvideo_ = false;
  path_ = NULL;
  width_ = 0;
  height_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Substrate::~Substrate() {
  SharedDtor();
}

void Substrate::SharedDtor() {
  if (this != default_instance_) {
    delete path_;
  }
}

void Substrate::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Substrate::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Substrate_descriptor_;
}

const Substrate& Substrate::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Substrate* Substrate::default_instance_ = NULL;

Substrate* Substrate::New() const {
  return new Substrate;
}

void Substrate::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    isimage_ = true;
    isvideo_ = false;
    if (has_path()) {
      if (path_ != NULL) path_->::FilePath::Clear();
    }
    width_ = 0;
    height_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Substrate::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool isImage = 1 [default = true];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isimage_)));
          set_has_isimage();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_isVideo;
        break;
      }
      
      // optional bool isVideo = 2 [default = false];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_isVideo:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &isvideo_)));
          set_has_isvideo();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_path;
        break;
      }
      
      // optional .FilePath path = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_path:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_path()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_width;
        break;
      }
      
      // optional int32 width = 4 [default = 0];
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(40)) goto parse_height;
        break;
      }
      
      // optional int32 height = 5 [default = 0];
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_height:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &height_)));
          set_has_height();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Substrate::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool isImage = 1 [default = true];
  if (has_isimage()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->isimage(), output);
  }
  
  // optional bool isVideo = 2 [default = false];
  if (has_isvideo()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(2, this->isvideo(), output);
  }
  
  // optional .FilePath path = 3;
  if (has_path()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->path(), output);
  }
  
  // optional int32 width = 4 [default = 0];
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(4, this->width(), output);
  }
  
  // optional int32 height = 5 [default = 0];
  if (has_height()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(5, this->height(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Substrate::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool isImage = 1 [default = true];
  if (has_isimage()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->isimage(), target);
  }
  
  // optional bool isVideo = 2 [default = false];
  if (has_isvideo()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(2, this->isvideo(), target);
  }
  
  // optional .FilePath path = 3;
  if (has_path()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->path(), target);
  }
  
  // optional int32 width = 4 [default = 0];
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(4, this->width(), target);
  }
  
  // optional int32 height = 5 [default = 0];
  if (has_height()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(5, this->height(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Substrate::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool isImage = 1 [default = true];
    if (has_isimage()) {
      total_size += 1 + 1;
    }
    
    // optional bool isVideo = 2 [default = false];
    if (has_isvideo()) {
      total_size += 1 + 1;
    }
    
    // optional .FilePath path = 3;
    if (has_path()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->path());
    }
    
    // optional int32 width = 4 [default = 0];
    if (has_width()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->width());
    }
    
    // optional int32 height = 5 [default = 0];
    if (has_height()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->height());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Substrate::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Substrate* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Substrate*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Substrate::MergeFrom(const Substrate& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_isimage()) {
      set_isimage(from.isimage());
    }
    if (from.has_isvideo()) {
      set_isvideo(from.isvideo());
    }
    if (from.has_path()) {
      mutable_path()->::FilePath::MergeFrom(from.path());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_height()) {
      set_height(from.height());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Substrate::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Substrate::CopyFrom(const Substrate& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Substrate::IsInitialized() const {
  
  return true;
}

void Substrate::Swap(Substrate* other) {
  if (other != this) {
    std::swap(isimage_, other->isimage_);
    std::swap(isvideo_, other->isvideo_);
    std::swap(path_, other->path_);
    std::swap(width_, other->width_);
    std::swap(height_, other->height_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Substrate::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Substrate_descriptor_;
  metadata.reflection = Substrate_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Semantics::kUrlFieldNumber;
#endif  // !_MSC_VER

Semantics::Semantics()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Semantics::InitAsDefaultInstance() {
}

Semantics::Semantics(const Semantics& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Semantics::SharedCtor() {
  _cached_size_ = 0;
  url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Semantics::~Semantics() {
  SharedDtor();
}

void Semantics::SharedDtor() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    delete url_;
  }
  if (this != default_instance_) {
  }
}

void Semantics::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Semantics::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Semantics_descriptor_;
}

const Semantics& Semantics::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Semantics* Semantics::default_instance_ = NULL;

Semantics* Semantics::New() const {
  return new Semantics;
}

void Semantics::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_url()) {
      if (url_ != &::google::protobuf::internal::kEmptyString) {
        url_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Semantics::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string url = 1 [default = ""];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_url()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->url().data(), this->url().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Semantics::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string url = 1 [default = ""];
  if (has_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->url(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Semantics::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string url = 1 [default = ""];
  if (has_url()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->url().data(), this->url().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->url(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Semantics::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string url = 1 [default = ""];
    if (has_url()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->url());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Semantics::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Semantics* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Semantics*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Semantics::MergeFrom(const Semantics& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_url()) {
      set_url(from.url());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Semantics::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Semantics::CopyFrom(const Semantics& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Semantics::IsInitialized() const {
  
  return true;
}

void Semantics::Swap(Semantics* other) {
  if (other != this) {
    std::swap(url_, other->url_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Semantics::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Semantics_descriptor_;
  metadata.reflection = Semantics_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LabelProperties::kKeyFieldNumber;
const int LabelProperties::kValueFieldNumber;
#endif  // !_MSC_VER

LabelProperties::LabelProperties()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LabelProperties::InitAsDefaultInstance() {
}

LabelProperties::LabelProperties(const LabelProperties& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LabelProperties::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LabelProperties::~LabelProperties() {
  SharedDtor();
}

void LabelProperties::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void LabelProperties::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LabelProperties::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LabelProperties_descriptor_;
}

const LabelProperties& LabelProperties::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

LabelProperties* LabelProperties::default_instance_ = NULL;

LabelProperties* LabelProperties::New() const {
  return new LabelProperties;
}

void LabelProperties::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LabelProperties::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string key = 1 [default = ""];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }
      
      // optional string value = 2 [default = ""];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LabelProperties::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional string key = 1 [default = ""];
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }
  
  // optional string value = 2 [default = ""];
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LabelProperties::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional string key = 1 [default = ""];
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }
  
  // optional string value = 2 [default = ""];
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LabelProperties::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional string key = 1 [default = ""];
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }
    
    // optional string value = 2 [default = ""];
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LabelProperties::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LabelProperties* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LabelProperties*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LabelProperties::MergeFrom(const LabelProperties& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LabelProperties::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LabelProperties::CopyFrom(const LabelProperties& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LabelProperties::IsInitialized() const {
  
  return true;
}

void LabelProperties::Swap(LabelProperties* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LabelProperties::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LabelProperties_descriptor_;
  metadata.reflection = LabelProperties_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Label::kHasLabelFieldNumber;
const int Label::kNameFieldNumber;
const int Label::kPropertiesFieldNumber;
const int Label::kSemantixFieldNumber;
#endif  // !_MSC_VER

Label::Label()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Label::InitAsDefaultInstance() {
  properties_ = const_cast< ::LabelProperties*>(&::LabelProperties::default_instance());
  semantix_ = const_cast< ::Semantics*>(&::Semantics::default_instance());
}

Label::Label(const Label& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Label::SharedCtor() {
  _cached_size_ = 0;
  haslabel_ = false;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  properties_ = NULL;
  semantix_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Label::~Label() {
  SharedDtor();
}

void Label::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (this != default_instance_) {
    delete properties_;
    delete semantix_;
  }
}

void Label::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Label::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Label_descriptor_;
}

const Label& Label::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Label* Label::default_instance_ = NULL;

Label* Label::New() const {
  return new Label;
}

void Label::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    haslabel_ = false;
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_properties()) {
      if (properties_ != NULL) properties_->::LabelProperties::Clear();
    }
    if (has_semantix()) {
      if (semantix_ != NULL) semantix_->::Semantics::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Label::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional bool hasLabel = 1 [default = false];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &haslabel_)));
          set_has_haslabel();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_name;
        break;
      }
      
      // optional string name = 2 [default = ""];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_name:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_properties;
        break;
      }
      
      // optional .LabelProperties properties = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_properties:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_properties()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(34)) goto parse_semantix;
        break;
      }
      
      // optional .Semantics semantix = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_semantix:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_semantix()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Label::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional bool hasLabel = 1 [default = false];
  if (has_haslabel()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(1, this->haslabel(), output);
  }
  
  // optional string name = 2 [default = ""];
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->name(), output);
  }
  
  // optional .LabelProperties properties = 3;
  if (has_properties()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->properties(), output);
  }
  
  // optional .Semantics semantix = 4;
  if (has_semantix()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, this->semantix(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Label::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional bool hasLabel = 1 [default = false];
  if (has_haslabel()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(1, this->haslabel(), target);
  }
  
  // optional string name = 2 [default = ""];
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }
  
  // optional .LabelProperties properties = 3;
  if (has_properties()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->properties(), target);
  }
  
  // optional .Semantics semantix = 4;
  if (has_semantix()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        4, this->semantix(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Label::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional bool hasLabel = 1 [default = false];
    if (has_haslabel()) {
      total_size += 1 + 1;
    }
    
    // optional string name = 2 [default = ""];
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }
    
    // optional .LabelProperties properties = 3;
    if (has_properties()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->properties());
    }
    
    // optional .Semantics semantix = 4;
    if (has_semantix()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->semantix());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Label::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Label* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Label*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Label::MergeFrom(const Label& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_haslabel()) {
      set_haslabel(from.haslabel());
    }
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_properties()) {
      mutable_properties()->::LabelProperties::MergeFrom(from.properties());
    }
    if (from.has_semantix()) {
      mutable_semantix()->::Semantics::MergeFrom(from.semantix());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Label::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Label::CopyFrom(const Label& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Label::IsInitialized() const {
  
  return true;
}

void Label::Swap(Label* other) {
  if (other != this) {
    std::swap(haslabel_, other->haslabel_);
    std::swap(name_, other->name_);
    std::swap(properties_, other->properties_);
    std::swap(semantix_, other->semantix_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Label::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Label_descriptor_;
  metadata.reflection = Label_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Labelable::kConfidenceFieldNumber;
const int Labelable::kLabFieldNumber;
const int Labelable::kSubFieldNumber;
#endif  // !_MSC_VER

Labelable::Labelable()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Labelable::InitAsDefaultInstance() {
  lab_ = const_cast< ::Label*>(&::Label::default_instance());
  sub_ = const_cast< ::Substrate*>(&::Substrate::default_instance());
}

Labelable::Labelable(const Labelable& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Labelable::SharedCtor() {
  _cached_size_ = 0;
  confidence_ = 0;
  lab_ = NULL;
  sub_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Labelable::~Labelable() {
  SharedDtor();
}

void Labelable::SharedDtor() {
  if (this != default_instance_) {
    delete lab_;
    delete sub_;
  }
}

void Labelable::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Labelable::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Labelable_descriptor_;
}

const Labelable& Labelable::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Labelable* Labelable::default_instance_ = NULL;

Labelable* Labelable::New() const {
  return new Labelable;
}

void Labelable::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    confidence_ = 0;
    if (has_lab()) {
      if (lab_ != NULL) lab_->::Label::Clear();
    }
    if (has_sub()) {
      if (sub_ != NULL) sub_->::Substrate::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Labelable::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional float confidence = 1 [default = 0];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   float, ::google::protobuf::internal::WireFormatLite::TYPE_FLOAT>(
                 input, &confidence_)));
          set_has_confidence();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_lab;
        break;
      }
      
      // optional .Label lab = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_lab:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_lab()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_sub;
        break;
      }
      
      // optional .Substrate sub = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_sub:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_sub()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Labelable::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional float confidence = 1 [default = 0];
  if (has_confidence()) {
    ::google::protobuf::internal::WireFormatLite::WriteFloat(1, this->confidence(), output);
  }
  
  // optional .Label lab = 2;
  if (has_lab()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->lab(), output);
  }
  
  // optional .Substrate sub = 3;
  if (has_sub()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->sub(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Labelable::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional float confidence = 1 [default = 0];
  if (has_confidence()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFloatToArray(1, this->confidence(), target);
  }
  
  // optional .Label lab = 2;
  if (has_lab()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->lab(), target);
  }
  
  // optional .Substrate sub = 3;
  if (has_sub()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->sub(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Labelable::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional float confidence = 1 [default = 0];
    if (has_confidence()) {
      total_size += 1 + 4;
    }
    
    // optional .Label lab = 2;
    if (has_lab()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->lab());
    }
    
    // optional .Substrate sub = 3;
    if (has_sub()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->sub());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Labelable::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Labelable* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Labelable*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Labelable::MergeFrom(const Labelable& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_confidence()) {
      set_confidence(from.confidence());
    }
    if (from.has_lab()) {
      mutable_lab()->::Label::MergeFrom(from.lab());
    }
    if (from.has_sub()) {
      mutable_sub()->::Substrate::MergeFrom(from.sub());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Labelable::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Labelable::CopyFrom(const Labelable& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Labelable::IsInitialized() const {
  
  return true;
}

void Labelable::Swap(Labelable* other) {
  if (other != this) {
    std::swap(confidence_, other->confidence_);
    std::swap(lab_, other->lab_);
    std::swap(sub_, other->sub_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Labelable::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Labelable_descriptor_;
  metadata.reflection = Labelable_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int LabelableList::kLabelableFieldNumber;
#endif  // !_MSC_VER

LabelableList::LabelableList()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LabelableList::InitAsDefaultInstance() {
}

LabelableList::LabelableList(const LabelableList& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LabelableList::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LabelableList::~LabelableList() {
  SharedDtor();
}

void LabelableList::SharedDtor() {
  if (this != default_instance_) {
  }
}

void LabelableList::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LabelableList::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LabelableList_descriptor_;
}

const LabelableList& LabelableList::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

LabelableList* LabelableList::default_instance_ = NULL;

LabelableList* LabelableList::New() const {
  return new LabelableList;
}

void LabelableList::Clear() {
  labelable_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LabelableList::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .Labelable labelable = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_labelable:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_labelable()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_labelable;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LabelableList::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .Labelable labelable = 1;
  for (int i = 0; i < this->labelable_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->labelable(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LabelableList::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .Labelable labelable = 1;
  for (int i = 0; i < this->labelable_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->labelable(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LabelableList::ByteSize() const {
  int total_size = 0;
  
  // repeated .Labelable labelable = 1;
  total_size += 1 * this->labelable_size();
  for (int i = 0; i < this->labelable_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->labelable(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LabelableList::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LabelableList* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LabelableList*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LabelableList::MergeFrom(const LabelableList& from) {
  GOOGLE_CHECK_NE(&from, this);
  labelable_.MergeFrom(from.labelable_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LabelableList::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LabelableList::CopyFrom(const LabelableList& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LabelableList::IsInitialized() const {
  
  return true;
}

void LabelableList::Swap(LabelableList* other) {
  if (other != this) {
    labelable_.Swap(&other->labelable_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LabelableList::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LabelableList_descriptor_;
  metadata.reflection = LabelableList_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* Purpose_PurposeType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Purpose_PurposeType_descriptor_;
}
bool Purpose_PurposeType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const Purpose_PurposeType Purpose::UNPURPOSED;
const Purpose_PurposeType Purpose::POSITIVE;
const Purpose_PurposeType Purpose::NEGATIVE;
const Purpose_PurposeType Purpose::MULTICLASS;
const Purpose_PurposeType Purpose::ANY;
const Purpose_PurposeType Purpose::PurposeType_MIN;
const Purpose_PurposeType Purpose::PurposeType_MAX;
const int Purpose::PurposeType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int Purpose::kPtypeFieldNumber;
const int Purpose::kClassIDFieldNumber;
#endif  // !_MSC_VER

Purpose::Purpose()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Purpose::InitAsDefaultInstance() {
}

Purpose::Purpose(const Purpose& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Purpose::SharedCtor() {
  _cached_size_ = 0;
  ptype_ = 0;
  classid_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Purpose::~Purpose() {
  SharedDtor();
}

void Purpose::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Purpose::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Purpose::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Purpose_descriptor_;
}

const Purpose& Purpose::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

Purpose* Purpose::default_instance_ = NULL;

Purpose* Purpose::New() const {
  return new Purpose;
}

void Purpose::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    ptype_ = 0;
    classid_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Purpose::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Purpose.PurposeType ptype = 1 [default = UNPURPOSED];
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::Purpose_PurposeType_IsValid(value)) {
            set_ptype(static_cast< ::Purpose_PurposeType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_classID;
        break;
      }
      
      // optional int32 classID = 2 [default = 0];
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_classID:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &classid_)));
          set_has_classid();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Purpose::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Purpose.PurposeType ptype = 1 [default = UNPURPOSED];
  if (has_ptype()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->ptype(), output);
  }
  
  // optional int32 classID = 2 [default = 0];
  if (has_classid()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->classid(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Purpose::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Purpose.PurposeType ptype = 1 [default = UNPURPOSED];
  if (has_ptype()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->ptype(), target);
  }
  
  // optional int32 classID = 2 [default = 0];
  if (has_classid()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->classid(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Purpose::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Purpose.PurposeType ptype = 1 [default = UNPURPOSED];
    if (has_ptype()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->ptype());
    }
    
    // optional int32 classID = 2 [default = 0];
    if (has_classid()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->classid());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Purpose::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Purpose* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Purpose*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Purpose::MergeFrom(const Purpose& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_ptype()) {
      set_ptype(from.ptype());
    }
    if (from.has_classid()) {
      set_classid(from.classid());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Purpose::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Purpose::CopyFrom(const Purpose& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Purpose::IsInitialized() const {
  
  return true;
}

void Purpose::Swap(Purpose* other) {
  if (other != this) {
    std::swap(ptype_, other->ptype_);
    std::swap(classid_, other->classid_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Purpose::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Purpose_descriptor_;
  metadata.reflection = Purpose_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PurposedLabelableSeq::kPurFieldNumber;
const int PurposedLabelableSeq::kLabeledArtifactsFieldNumber;
#endif  // !_MSC_VER

PurposedLabelableSeq::PurposedLabelableSeq()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PurposedLabelableSeq::InitAsDefaultInstance() {
  pur_ = const_cast< ::Purpose*>(&::Purpose::default_instance());
  labeledartifacts_ = const_cast< ::LabelableList*>(&::LabelableList::default_instance());
}

PurposedLabelableSeq::PurposedLabelableSeq(const PurposedLabelableSeq& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PurposedLabelableSeq::SharedCtor() {
  _cached_size_ = 0;
  pur_ = NULL;
  labeledartifacts_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PurposedLabelableSeq::~PurposedLabelableSeq() {
  SharedDtor();
}

void PurposedLabelableSeq::SharedDtor() {
  if (this != default_instance_) {
    delete pur_;
    delete labeledartifacts_;
  }
}

void PurposedLabelableSeq::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PurposedLabelableSeq::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PurposedLabelableSeq_descriptor_;
}

const PurposedLabelableSeq& PurposedLabelableSeq::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

PurposedLabelableSeq* PurposedLabelableSeq::default_instance_ = NULL;

PurposedLabelableSeq* PurposedLabelableSeq::New() const {
  return new PurposedLabelableSeq;
}

void PurposedLabelableSeq::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_pur()) {
      if (pur_ != NULL) pur_->::Purpose::Clear();
    }
    if (has_labeledartifacts()) {
      if (labeledartifacts_ != NULL) labeledartifacts_->::LabelableList::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PurposedLabelableSeq::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .Purpose pur = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pur()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_labeledArtifacts;
        break;
      }
      
      // optional .LabelableList labeledArtifacts = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_labeledArtifacts:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_labeledartifacts()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PurposedLabelableSeq::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .Purpose pur = 1;
  if (has_pur()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->pur(), output);
  }
  
  // optional .LabelableList labeledArtifacts = 2;
  if (has_labeledartifacts()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->labeledartifacts(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PurposedLabelableSeq::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .Purpose pur = 1;
  if (has_pur()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->pur(), target);
  }
  
  // optional .LabelableList labeledArtifacts = 2;
  if (has_labeledartifacts()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->labeledartifacts(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PurposedLabelableSeq::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .Purpose pur = 1;
    if (has_pur()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pur());
    }
    
    // optional .LabelableList labeledArtifacts = 2;
    if (has_labeledartifacts()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->labeledartifacts());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PurposedLabelableSeq::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PurposedLabelableSeq* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PurposedLabelableSeq*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PurposedLabelableSeq::MergeFrom(const PurposedLabelableSeq& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_pur()) {
      mutable_pur()->::Purpose::MergeFrom(from.pur());
    }
    if (from.has_labeledartifacts()) {
      mutable_labeledartifacts()->::LabelableList::MergeFrom(from.labeledartifacts());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PurposedLabelableSeq::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PurposedLabelableSeq::CopyFrom(const PurposedLabelableSeq& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurposedLabelableSeq::IsInitialized() const {
  
  return true;
}

void PurposedLabelableSeq::Swap(PurposedLabelableSeq* other) {
  if (other != this) {
    std::swap(pur_, other->pur_);
    std::swap(labeledartifacts_, other->labeledartifacts_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PurposedLabelableSeq::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PurposedLabelableSeq_descriptor_;
  metadata.reflection = PurposedLabelableSeq_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int PurposedListSequence::kPurlistFieldNumber;
#endif  // !_MSC_VER

PurposedListSequence::PurposedListSequence()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PurposedListSequence::InitAsDefaultInstance() {
}

PurposedListSequence::PurposedListSequence(const PurposedListSequence& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PurposedListSequence::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PurposedListSequence::~PurposedListSequence() {
  SharedDtor();
}

void PurposedListSequence::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PurposedListSequence::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PurposedListSequence::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PurposedListSequence_descriptor_;
}

const PurposedListSequence& PurposedListSequence::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

PurposedListSequence* PurposedListSequence::default_instance_ = NULL;

PurposedListSequence* PurposedListSequence::New() const {
  return new PurposedListSequence;
}

void PurposedListSequence::Clear() {
  purlist_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PurposedListSequence::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .PurposedLabelableSeq purlist = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_purlist:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_purlist()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_purlist;
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PurposedListSequence::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .PurposedLabelableSeq purlist = 1;
  for (int i = 0; i < this->purlist_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->purlist(i), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PurposedListSequence::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .PurposedLabelableSeq purlist = 1;
  for (int i = 0; i < this->purlist_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->purlist(i), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PurposedListSequence::ByteSize() const {
  int total_size = 0;
  
  // repeated .PurposedLabelableSeq purlist = 1;
  total_size += 1 * this->purlist_size();
  for (int i = 0; i < this->purlist_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->purlist(i));
  }
  
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PurposedListSequence::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PurposedListSequence* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PurposedListSequence*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PurposedListSequence::MergeFrom(const PurposedListSequence& from) {
  GOOGLE_CHECK_NE(&from, this);
  purlist_.MergeFrom(from.purlist_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PurposedListSequence::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PurposedListSequence::CopyFrom(const PurposedListSequence& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PurposedListSequence::IsInitialized() const {
  
  return true;
}

void PurposedListSequence::Swap(PurposedListSequence* other) {
  if (other != this) {
    purlist_.Swap(&other->purlist_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PurposedListSequence::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PurposedListSequence_descriptor_;
  metadata.reflection = PurposedListSequence_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int RunSet::kPurposedListsFieldNumber;
#endif  // !_MSC_VER

RunSet::RunSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void RunSet::InitAsDefaultInstance() {
  purposedlists_ = const_cast< ::PurposedListSequence*>(&::PurposedListSequence::default_instance());
}

RunSet::RunSet(const RunSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void RunSet::SharedCtor() {
  _cached_size_ = 0;
  purposedlists_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

RunSet::~RunSet() {
  SharedDtor();
}

void RunSet::SharedDtor() {
  if (this != default_instance_) {
    delete purposedlists_;
  }
}

void RunSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* RunSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return RunSet_descriptor_;
}

const RunSet& RunSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();  return *default_instance_;
}

RunSet* RunSet::default_instance_ = NULL;

RunSet* RunSet::New() const {
  return new RunSet;
}

void RunSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_purposedlists()) {
      if (purposedlists_ != NULL) purposedlists_->::PurposedListSequence::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool RunSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .PurposedListSequence purposedLists = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_purposedlists()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }
      
      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void RunSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .PurposedListSequence purposedLists = 1;
  if (has_purposedlists()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->purposedlists(), output);
  }
  
  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* RunSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .PurposedListSequence purposedLists = 1;
  if (has_purposedlists()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->purposedlists(), target);
  }
  
  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int RunSet::ByteSize() const {
  int total_size = 0;
  
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .PurposedListSequence purposedLists = 1;
    if (has_purposedlists()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->purposedlists());
    }
    
  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void RunSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const RunSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const RunSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void RunSet::MergeFrom(const RunSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_purposedlists()) {
      mutable_purposedlists()->::PurposedListSequence::MergeFrom(from.purposedlists());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void RunSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void RunSet::CopyFrom(const RunSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool RunSet::IsInitialized() const {
  
  return true;
}

void RunSet::Swap(RunSet* other) {
  if (other != this) {
    std::swap(purposedlists_, other->purposedlists_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata RunSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = RunSet_descriptor_;
  metadata.reflection = RunSet_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)
