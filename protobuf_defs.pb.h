// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: algorithms/matlab_bridge/protobuf_defs.proto

#ifndef PROTOBUF_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto__INCLUDED
#define PROTOBUF_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2004000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2004001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();

class MatlabBridgeMsg;
class Model;
class ServiceDefinition;
class Result;
class ResultList;
class ResultSet;
class DirectoryPath;
class FilePath;
class Substrate;
class Semantics;
class LabelProperties;
class Label;
class Labelable;
class LabelableList;
class Purpose;
class PurposedLabelableSeq;
class PurposedListSequence;
class RunSet;

enum Purpose_PurposeType {
  Purpose_PurposeType_UNPURPOSED = 0,
  Purpose_PurposeType_POSITIVE = 1,
  Purpose_PurposeType_NEGATIVE = 2,
  Purpose_PurposeType_MULTICLASS = 3,
  Purpose_PurposeType_ANY = 4
};
bool Purpose_PurposeType_IsValid(int value);
const Purpose_PurposeType Purpose_PurposeType_PurposeType_MIN = Purpose_PurposeType_UNPURPOSED;
const Purpose_PurposeType Purpose_PurposeType_PurposeType_MAX = Purpose_PurposeType_ANY;
const int Purpose_PurposeType_PurposeType_ARRAYSIZE = Purpose_PurposeType_PurposeType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Purpose_PurposeType_descriptor();
inline const ::std::string& Purpose_PurposeType_Name(Purpose_PurposeType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Purpose_PurposeType_descriptor(), value);
}
inline bool Purpose_PurposeType_Parse(
    const ::std::string& name, Purpose_PurposeType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Purpose_PurposeType>(
    Purpose_PurposeType_descriptor(), name, value);
}
// ===================================================================

class MatlabBridgeMsg : public ::google::protobuf::Message {
 public:
  MatlabBridgeMsg();
  virtual ~MatlabBridgeMsg();
  
  MatlabBridgeMsg(const MatlabBridgeMsg& from);
  
  inline MatlabBridgeMsg& operator=(const MatlabBridgeMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const MatlabBridgeMsg& default_instance();
  
  void Swap(MatlabBridgeMsg* other);
  
  // implements Message ----------------------------------------------
  
  MatlabBridgeMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const MatlabBridgeMsg& from);
  void MergeFrom(const MatlabBridgeMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .RunSet run = 1;
  inline bool has_run() const;
  inline void clear_run();
  static const int kRunFieldNumber = 1;
  inline const ::RunSet& run() const;
  inline ::RunSet* mutable_run();
  inline ::RunSet* release_run();
  
  // repeated .ServiceDefinition serviceDef = 2;
  inline int servicedef_size() const;
  inline void clear_servicedef();
  static const int kServiceDefFieldNumber = 2;
  inline const ::ServiceDefinition& servicedef(int index) const;
  inline ::ServiceDefinition* mutable_servicedef(int index);
  inline ::ServiceDefinition* add_servicedef();
  inline const ::google::protobuf::RepeatedPtrField< ::ServiceDefinition >&
      servicedef() const;
  inline ::google::protobuf::RepeatedPtrField< ::ServiceDefinition >*
      mutable_servicedef();
  
  // optional .ResultSet res = 3;
  inline bool has_res() const;
  inline void clear_res();
  static const int kResFieldNumber = 3;
  inline const ::ResultSet& res() const;
  inline ::ResultSet* mutable_res();
  inline ::ResultSet* release_res();
  
  // optional .Model model = 4;
  inline bool has_model() const;
  inline void clear_model();
  static const int kModelFieldNumber = 4;
  inline const ::Model& model() const;
  inline ::Model* mutable_model();
  inline ::Model* release_model();
  
  // @@protoc_insertion_point(class_scope:MatlabBridgeMsg)
 private:
  inline void set_has_run();
  inline void clear_has_run();
  inline void set_has_res();
  inline void clear_has_res();
  inline void set_has_model();
  inline void clear_has_model();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::RunSet* run_;
  ::google::protobuf::RepeatedPtrField< ::ServiceDefinition > servicedef_;
  ::ResultSet* res_;
  ::Model* model_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static MatlabBridgeMsg* default_instance_;
};
// -------------------------------------------------------------------

class Model : public ::google::protobuf::Message {
 public:
  Model();
  virtual ~Model();
  
  Model(const Model& from);
  
  inline Model& operator=(const Model& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Model& default_instance();
  
  void Swap(Model* other);
  
  // implements Message ----------------------------------------------
  
  Model* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Model& from);
  void MergeFrom(const Model& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .FilePath mPath = 1;
  inline bool has_mpath() const;
  inline void clear_mpath();
  static const int kMPathFieldNumber = 1;
  inline const ::FilePath& mpath() const;
  inline ::FilePath* mutable_mpath();
  inline ::FilePath* release_mpath();
  
  // @@protoc_insertion_point(class_scope:Model)
 private:
  inline void set_has_mpath();
  inline void clear_has_mpath();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::FilePath* mpath_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Model* default_instance_;
};
// -------------------------------------------------------------------

class ServiceDefinition : public ::google::protobuf::Message {
 public:
  ServiceDefinition();
  virtual ~ServiceDefinition();
  
  ServiceDefinition(const ServiceDefinition& from);
  
  inline ServiceDefinition& operator=(const ServiceDefinition& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ServiceDefinition& default_instance();
  
  void Swap(ServiceDefinition* other);
  
  // implements Message ----------------------------------------------
  
  ServiceDefinition* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ServiceDefinition& from);
  void MergeFrom(const ServiceDefinition& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1 [default = ""];
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional string value = 2 [default = ""];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:ServiceDefinition)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static ServiceDefinition* default_instance_;
};
// -------------------------------------------------------------------

class Result : public ::google::protobuf::Message {
 public:
  Result();
  virtual ~Result();
  
  Result(const Result& from);
  
  inline Result& operator=(const Result& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Result& default_instance();
  
  void Swap(Result* other);
  
  // implements Message ----------------------------------------------
  
  Result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Result& from);
  void MergeFrom(const Result& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Labelable original = 1;
  inline bool has_original() const;
  inline void clear_original();
  static const int kOriginalFieldNumber = 1;
  inline const ::Labelable& original() const;
  inline ::Labelable* mutable_original();
  inline ::Labelable* release_original();
  
  // optional .LabelableList foundLabels = 2;
  inline bool has_foundlabels() const;
  inline void clear_foundlabels();
  static const int kFoundLabelsFieldNumber = 2;
  inline const ::LabelableList& foundlabels() const;
  inline ::LabelableList* mutable_foundlabels();
  inline ::LabelableList* release_foundlabels();
  
  // @@protoc_insertion_point(class_scope:Result)
 private:
  inline void set_has_original();
  inline void clear_has_original();
  inline void set_has_foundlabels();
  inline void clear_has_foundlabels();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Labelable* original_;
  ::LabelableList* foundlabels_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Result* default_instance_;
};
// -------------------------------------------------------------------

class ResultList : public ::google::protobuf::Message {
 public:
  ResultList();
  virtual ~ResultList();
  
  ResultList(const ResultList& from);
  
  inline ResultList& operator=(const ResultList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultList& default_instance();
  
  void Swap(ResultList* other);
  
  // implements Message ----------------------------------------------
  
  ResultList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultList& from);
  void MergeFrom(const ResultList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Result rslt = 1;
  inline int rslt_size() const;
  inline void clear_rslt();
  static const int kRsltFieldNumber = 1;
  inline const ::Result& rslt(int index) const;
  inline ::Result* mutable_rslt(int index);
  inline ::Result* add_rslt();
  inline const ::google::protobuf::RepeatedPtrField< ::Result >&
      rslt() const;
  inline ::google::protobuf::RepeatedPtrField< ::Result >*
      mutable_rslt();
  
  // @@protoc_insertion_point(class_scope:ResultList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Result > rslt_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static ResultList* default_instance_;
};
// -------------------------------------------------------------------

class ResultSet : public ::google::protobuf::Message {
 public:
  ResultSet();
  virtual ~ResultSet();
  
  ResultSet(const ResultSet& from);
  
  inline ResultSet& operator=(const ResultSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const ResultSet& default_instance();
  
  void Swap(ResultSet* other);
  
  // implements Message ----------------------------------------------
  
  ResultSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ResultSet& from);
  void MergeFrom(const ResultSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .ResultList results = 1;
  inline bool has_results() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 1;
  inline const ::ResultList& results() const;
  inline ::ResultList* mutable_results();
  inline ::ResultList* release_results();
  
  // @@protoc_insertion_point(class_scope:ResultSet)
 private:
  inline void set_has_results();
  inline void clear_has_results();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::ResultList* results_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static ResultSet* default_instance_;
};
// -------------------------------------------------------------------

class DirectoryPath : public ::google::protobuf::Message {
 public:
  DirectoryPath();
  virtual ~DirectoryPath();
  
  DirectoryPath(const DirectoryPath& from);
  
  inline DirectoryPath& operator=(const DirectoryPath& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectoryPath& default_instance();
  
  void Swap(DirectoryPath* other);
  
  // implements Message ----------------------------------------------
  
  DirectoryPath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectoryPath& from);
  void MergeFrom(const DirectoryPath& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string relativePath = 1 [default = ""];
  inline bool has_relativepath() const;
  inline void clear_relativepath();
  static const int kRelativePathFieldNumber = 1;
  inline const ::std::string& relativepath() const;
  inline void set_relativepath(const ::std::string& value);
  inline void set_relativepath(const char* value);
  inline void set_relativepath(const char* value, size_t size);
  inline ::std::string* mutable_relativepath();
  inline ::std::string* release_relativepath();
  
  // @@protoc_insertion_point(class_scope:DirectoryPath)
 private:
  inline void set_has_relativepath();
  inline void clear_has_relativepath();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* relativepath_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static DirectoryPath* default_instance_;
};
// -------------------------------------------------------------------

class FilePath : public ::google::protobuf::Message {
 public:
  FilePath();
  virtual ~FilePath();
  
  FilePath(const FilePath& from);
  
  inline FilePath& operator=(const FilePath& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const FilePath& default_instance();
  
  void Swap(FilePath* other);
  
  // implements Message ----------------------------------------------
  
  FilePath* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FilePath& from);
  void MergeFrom(const FilePath& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .DirectoryPath directory = 1;
  inline bool has_directory() const;
  inline void clear_directory();
  static const int kDirectoryFieldNumber = 1;
  inline const ::DirectoryPath& directory() const;
  inline ::DirectoryPath* mutable_directory();
  inline ::DirectoryPath* release_directory();
  
  // optional string filename = 2 [default = ""];
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 2;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  
  // @@protoc_insertion_point(class_scope:FilePath)
 private:
  inline void set_has_directory();
  inline void clear_has_directory();
  inline void set_has_filename();
  inline void clear_has_filename();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::DirectoryPath* directory_;
  ::std::string* filename_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static FilePath* default_instance_;
};
// -------------------------------------------------------------------

class Substrate : public ::google::protobuf::Message {
 public:
  Substrate();
  virtual ~Substrate();
  
  Substrate(const Substrate& from);
  
  inline Substrate& operator=(const Substrate& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Substrate& default_instance();
  
  void Swap(Substrate* other);
  
  // implements Message ----------------------------------------------
  
  Substrate* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Substrate& from);
  void MergeFrom(const Substrate& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool isImage = 1 [default = true];
  inline bool has_isimage() const;
  inline void clear_isimage();
  static const int kIsImageFieldNumber = 1;
  inline bool isimage() const;
  inline void set_isimage(bool value);
  
  // optional bool isVideo = 2 [default = false];
  inline bool has_isvideo() const;
  inline void clear_isvideo();
  static const int kIsVideoFieldNumber = 2;
  inline bool isvideo() const;
  inline void set_isvideo(bool value);
  
  // optional .FilePath path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::FilePath& path() const;
  inline ::FilePath* mutable_path();
  inline ::FilePath* release_path();
  
  // optional int32 width = 4 [default = 0];
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 4;
  inline ::google::protobuf::int32 width() const;
  inline void set_width(::google::protobuf::int32 value);
  
  // optional int32 height = 5 [default = 0];
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 5;
  inline ::google::protobuf::int32 height() const;
  inline void set_height(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Substrate)
 private:
  inline void set_has_isimage();
  inline void clear_has_isimage();
  inline void set_has_isvideo();
  inline void clear_has_isvideo();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  bool isimage_;
  bool isvideo_;
  ::google::protobuf::int32 width_;
  ::FilePath* path_;
  ::google::protobuf::int32 height_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Substrate* default_instance_;
};
// -------------------------------------------------------------------

class Semantics : public ::google::protobuf::Message {
 public:
  Semantics();
  virtual ~Semantics();
  
  Semantics(const Semantics& from);
  
  inline Semantics& operator=(const Semantics& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Semantics& default_instance();
  
  void Swap(Semantics* other);
  
  // implements Message ----------------------------------------------
  
  Semantics* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Semantics& from);
  void MergeFrom(const Semantics& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string url = 1 [default = ""];
  inline bool has_url() const;
  inline void clear_url();
  static const int kUrlFieldNumber = 1;
  inline const ::std::string& url() const;
  inline void set_url(const ::std::string& value);
  inline void set_url(const char* value);
  inline void set_url(const char* value, size_t size);
  inline ::std::string* mutable_url();
  inline ::std::string* release_url();
  
  // @@protoc_insertion_point(class_scope:Semantics)
 private:
  inline void set_has_url();
  inline void clear_has_url();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* url_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Semantics* default_instance_;
};
// -------------------------------------------------------------------

class LabelProperties : public ::google::protobuf::Message {
 public:
  LabelProperties();
  virtual ~LabelProperties();
  
  LabelProperties(const LabelProperties& from);
  
  inline LabelProperties& operator=(const LabelProperties& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelProperties& default_instance();
  
  void Swap(LabelProperties* other);
  
  // implements Message ----------------------------------------------
  
  LabelProperties* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabelProperties& from);
  void MergeFrom(const LabelProperties& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string key = 1 [default = ""];
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  
  // optional string value = 2 [default = ""];
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  
  // @@protoc_insertion_point(class_scope:LabelProperties)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* key_;
  ::std::string* value_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static LabelProperties* default_instance_;
};
// -------------------------------------------------------------------

class Label : public ::google::protobuf::Message {
 public:
  Label();
  virtual ~Label();
  
  Label(const Label& from);
  
  inline Label& operator=(const Label& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Label& default_instance();
  
  void Swap(Label* other);
  
  // implements Message ----------------------------------------------
  
  Label* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Label& from);
  void MergeFrom(const Label& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bool hasLabel = 1 [default = false];
  inline bool has_haslabel() const;
  inline void clear_haslabel();
  static const int kHasLabelFieldNumber = 1;
  inline bool haslabel() const;
  inline void set_haslabel(bool value);
  
  // optional string name = 2 [default = ""];
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  
  // optional .LabelProperties properties = 3;
  inline bool has_properties() const;
  inline void clear_properties();
  static const int kPropertiesFieldNumber = 3;
  inline const ::LabelProperties& properties() const;
  inline ::LabelProperties* mutable_properties();
  inline ::LabelProperties* release_properties();
  
  // optional .Semantics semantix = 4;
  inline bool has_semantix() const;
  inline void clear_semantix();
  static const int kSemantixFieldNumber = 4;
  inline const ::Semantics& semantix() const;
  inline ::Semantics* mutable_semantix();
  inline ::Semantics* release_semantix();
  
  // @@protoc_insertion_point(class_scope:Label)
 private:
  inline void set_has_haslabel();
  inline void clear_has_haslabel();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_properties();
  inline void clear_has_properties();
  inline void set_has_semantix();
  inline void clear_has_semantix();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::std::string* name_;
  ::LabelProperties* properties_;
  ::Semantics* semantix_;
  bool haslabel_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Label* default_instance_;
};
// -------------------------------------------------------------------

class Labelable : public ::google::protobuf::Message {
 public:
  Labelable();
  virtual ~Labelable();
  
  Labelable(const Labelable& from);
  
  inline Labelable& operator=(const Labelable& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Labelable& default_instance();
  
  void Swap(Labelable* other);
  
  // implements Message ----------------------------------------------
  
  Labelable* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Labelable& from);
  void MergeFrom(const Labelable& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional float confidence = 1 [default = 0];
  inline bool has_confidence() const;
  inline void clear_confidence();
  static const int kConfidenceFieldNumber = 1;
  inline float confidence() const;
  inline void set_confidence(float value);
  
  // optional .Label lab = 2;
  inline bool has_lab() const;
  inline void clear_lab();
  static const int kLabFieldNumber = 2;
  inline const ::Label& lab() const;
  inline ::Label* mutable_lab();
  inline ::Label* release_lab();
  
  // optional .Substrate sub = 3;
  inline bool has_sub() const;
  inline void clear_sub();
  static const int kSubFieldNumber = 3;
  inline const ::Substrate& sub() const;
  inline ::Substrate* mutable_sub();
  inline ::Substrate* release_sub();
  
  // @@protoc_insertion_point(class_scope:Labelable)
 private:
  inline void set_has_confidence();
  inline void clear_has_confidence();
  inline void set_has_lab();
  inline void clear_has_lab();
  inline void set_has_sub();
  inline void clear_has_sub();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Label* lab_;
  ::Substrate* sub_;
  float confidence_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Labelable* default_instance_;
};
// -------------------------------------------------------------------

class LabelableList : public ::google::protobuf::Message {
 public:
  LabelableList();
  virtual ~LabelableList();
  
  LabelableList(const LabelableList& from);
  
  inline LabelableList& operator=(const LabelableList& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const LabelableList& default_instance();
  
  void Swap(LabelableList* other);
  
  // implements Message ----------------------------------------------
  
  LabelableList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LabelableList& from);
  void MergeFrom(const LabelableList& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .Labelable labelable = 1;
  inline int labelable_size() const;
  inline void clear_labelable();
  static const int kLabelableFieldNumber = 1;
  inline const ::Labelable& labelable(int index) const;
  inline ::Labelable* mutable_labelable(int index);
  inline ::Labelable* add_labelable();
  inline const ::google::protobuf::RepeatedPtrField< ::Labelable >&
      labelable() const;
  inline ::google::protobuf::RepeatedPtrField< ::Labelable >*
      mutable_labelable();
  
  // @@protoc_insertion_point(class_scope:LabelableList)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::Labelable > labelable_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static LabelableList* default_instance_;
};
// -------------------------------------------------------------------

class Purpose : public ::google::protobuf::Message {
 public:
  Purpose();
  virtual ~Purpose();
  
  Purpose(const Purpose& from);
  
  inline Purpose& operator=(const Purpose& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const Purpose& default_instance();
  
  void Swap(Purpose* other);
  
  // implements Message ----------------------------------------------
  
  Purpose* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Purpose& from);
  void MergeFrom(const Purpose& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef Purpose_PurposeType PurposeType;
  static const PurposeType UNPURPOSED = Purpose_PurposeType_UNPURPOSED;
  static const PurposeType POSITIVE = Purpose_PurposeType_POSITIVE;
  static const PurposeType NEGATIVE = Purpose_PurposeType_NEGATIVE;
  static const PurposeType MULTICLASS = Purpose_PurposeType_MULTICLASS;
  static const PurposeType ANY = Purpose_PurposeType_ANY;
  static inline bool PurposeType_IsValid(int value) {
    return Purpose_PurposeType_IsValid(value);
  }
  static const PurposeType PurposeType_MIN =
    Purpose_PurposeType_PurposeType_MIN;
  static const PurposeType PurposeType_MAX =
    Purpose_PurposeType_PurposeType_MAX;
  static const int PurposeType_ARRAYSIZE =
    Purpose_PurposeType_PurposeType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PurposeType_descriptor() {
    return Purpose_PurposeType_descriptor();
  }
  static inline const ::std::string& PurposeType_Name(PurposeType value) {
    return Purpose_PurposeType_Name(value);
  }
  static inline bool PurposeType_Parse(const ::std::string& name,
      PurposeType* value) {
    return Purpose_PurposeType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional .Purpose.PurposeType ptype = 1 [default = UNPURPOSED];
  inline bool has_ptype() const;
  inline void clear_ptype();
  static const int kPtypeFieldNumber = 1;
  inline ::Purpose_PurposeType ptype() const;
  inline void set_ptype(::Purpose_PurposeType value);
  
  // optional int32 classID = 2 [default = 0];
  inline bool has_classid() const;
  inline void clear_classid();
  static const int kClassIDFieldNumber = 2;
  inline ::google::protobuf::int32 classid() const;
  inline void set_classid(::google::protobuf::int32 value);
  
  // @@protoc_insertion_point(class_scope:Purpose)
 private:
  inline void set_has_ptype();
  inline void clear_has_ptype();
  inline void set_has_classid();
  inline void clear_has_classid();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  int ptype_;
  ::google::protobuf::int32 classid_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static Purpose* default_instance_;
};
// -------------------------------------------------------------------

class PurposedLabelableSeq : public ::google::protobuf::Message {
 public:
  PurposedLabelableSeq();
  virtual ~PurposedLabelableSeq();
  
  PurposedLabelableSeq(const PurposedLabelableSeq& from);
  
  inline PurposedLabelableSeq& operator=(const PurposedLabelableSeq& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PurposedLabelableSeq& default_instance();
  
  void Swap(PurposedLabelableSeq* other);
  
  // implements Message ----------------------------------------------
  
  PurposedLabelableSeq* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PurposedLabelableSeq& from);
  void MergeFrom(const PurposedLabelableSeq& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .Purpose pur = 1;
  inline bool has_pur() const;
  inline void clear_pur();
  static const int kPurFieldNumber = 1;
  inline const ::Purpose& pur() const;
  inline ::Purpose* mutable_pur();
  inline ::Purpose* release_pur();
  
  // optional .LabelableList labeledArtifacts = 2;
  inline bool has_labeledartifacts() const;
  inline void clear_labeledartifacts();
  static const int kLabeledArtifactsFieldNumber = 2;
  inline const ::LabelableList& labeledartifacts() const;
  inline ::LabelableList* mutable_labeledartifacts();
  inline ::LabelableList* release_labeledartifacts();
  
  // @@protoc_insertion_point(class_scope:PurposedLabelableSeq)
 private:
  inline void set_has_pur();
  inline void clear_has_pur();
  inline void set_has_labeledartifacts();
  inline void clear_has_labeledartifacts();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::Purpose* pur_;
  ::LabelableList* labeledartifacts_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static PurposedLabelableSeq* default_instance_;
};
// -------------------------------------------------------------------

class PurposedListSequence : public ::google::protobuf::Message {
 public:
  PurposedListSequence();
  virtual ~PurposedListSequence();
  
  PurposedListSequence(const PurposedListSequence& from);
  
  inline PurposedListSequence& operator=(const PurposedListSequence& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const PurposedListSequence& default_instance();
  
  void Swap(PurposedListSequence* other);
  
  // implements Message ----------------------------------------------
  
  PurposedListSequence* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PurposedListSequence& from);
  void MergeFrom(const PurposedListSequence& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // repeated .PurposedLabelableSeq purlist = 1;
  inline int purlist_size() const;
  inline void clear_purlist();
  static const int kPurlistFieldNumber = 1;
  inline const ::PurposedLabelableSeq& purlist(int index) const;
  inline ::PurposedLabelableSeq* mutable_purlist(int index);
  inline ::PurposedLabelableSeq* add_purlist();
  inline const ::google::protobuf::RepeatedPtrField< ::PurposedLabelableSeq >&
      purlist() const;
  inline ::google::protobuf::RepeatedPtrField< ::PurposedLabelableSeq >*
      mutable_purlist();
  
  // @@protoc_insertion_point(class_scope:PurposedListSequence)
 private:
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::google::protobuf::RepeatedPtrField< ::PurposedLabelableSeq > purlist_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static PurposedListSequence* default_instance_;
};
// -------------------------------------------------------------------

class RunSet : public ::google::protobuf::Message {
 public:
  RunSet();
  virtual ~RunSet();
  
  RunSet(const RunSet& from);
  
  inline RunSet& operator=(const RunSet& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const RunSet& default_instance();
  
  void Swap(RunSet* other);
  
  // implements Message ----------------------------------------------
  
  RunSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RunSet& from);
  void MergeFrom(const RunSet& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional .PurposedListSequence purposedLists = 1;
  inline bool has_purposedlists() const;
  inline void clear_purposedlists();
  static const int kPurposedListsFieldNumber = 1;
  inline const ::PurposedListSequence& purposedlists() const;
  inline ::PurposedListSequence* mutable_purposedlists();
  inline ::PurposedListSequence* release_purposedlists();
  
  // @@protoc_insertion_point(class_scope:RunSet)
 private:
  inline void set_has_purposedlists();
  inline void clear_has_purposedlists();
  
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  
  ::PurposedListSequence* purposedlists_;
  
  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  friend void  protobuf_AddDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_AssignDesc_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  friend void protobuf_ShutdownFile_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto();
  
  void InitAsDefaultInstance();
  static RunSet* default_instance_;
};
// ===================================================================


// ===================================================================

// MatlabBridgeMsg

// optional .RunSet run = 1;
inline bool MatlabBridgeMsg::has_run() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MatlabBridgeMsg::set_has_run() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MatlabBridgeMsg::clear_has_run() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MatlabBridgeMsg::clear_run() {
  if (run_ != NULL) run_->::RunSet::Clear();
  clear_has_run();
}
inline const ::RunSet& MatlabBridgeMsg::run() const {
  return run_ != NULL ? *run_ : *default_instance_->run_;
}
inline ::RunSet* MatlabBridgeMsg::mutable_run() {
  set_has_run();
  if (run_ == NULL) run_ = new ::RunSet;
  return run_;
}
inline ::RunSet* MatlabBridgeMsg::release_run() {
  clear_has_run();
  ::RunSet* temp = run_;
  run_ = NULL;
  return temp;
}

// repeated .ServiceDefinition serviceDef = 2;
inline int MatlabBridgeMsg::servicedef_size() const {
  return servicedef_.size();
}
inline void MatlabBridgeMsg::clear_servicedef() {
  servicedef_.Clear();
}
inline const ::ServiceDefinition& MatlabBridgeMsg::servicedef(int index) const {
  return servicedef_.Get(index);
}
inline ::ServiceDefinition* MatlabBridgeMsg::mutable_servicedef(int index) {
  return servicedef_.Mutable(index);
}
inline ::ServiceDefinition* MatlabBridgeMsg::add_servicedef() {
  return servicedef_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::ServiceDefinition >&
MatlabBridgeMsg::servicedef() const {
  return servicedef_;
}
inline ::google::protobuf::RepeatedPtrField< ::ServiceDefinition >*
MatlabBridgeMsg::mutable_servicedef() {
  return &servicedef_;
}

// optional .ResultSet res = 3;
inline bool MatlabBridgeMsg::has_res() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MatlabBridgeMsg::set_has_res() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MatlabBridgeMsg::clear_has_res() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MatlabBridgeMsg::clear_res() {
  if (res_ != NULL) res_->::ResultSet::Clear();
  clear_has_res();
}
inline const ::ResultSet& MatlabBridgeMsg::res() const {
  return res_ != NULL ? *res_ : *default_instance_->res_;
}
inline ::ResultSet* MatlabBridgeMsg::mutable_res() {
  set_has_res();
  if (res_ == NULL) res_ = new ::ResultSet;
  return res_;
}
inline ::ResultSet* MatlabBridgeMsg::release_res() {
  clear_has_res();
  ::ResultSet* temp = res_;
  res_ = NULL;
  return temp;
}

// optional .Model model = 4;
inline bool MatlabBridgeMsg::has_model() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MatlabBridgeMsg::set_has_model() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MatlabBridgeMsg::clear_has_model() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MatlabBridgeMsg::clear_model() {
  if (model_ != NULL) model_->::Model::Clear();
  clear_has_model();
}
inline const ::Model& MatlabBridgeMsg::model() const {
  return model_ != NULL ? *model_ : *default_instance_->model_;
}
inline ::Model* MatlabBridgeMsg::mutable_model() {
  set_has_model();
  if (model_ == NULL) model_ = new ::Model;
  return model_;
}
inline ::Model* MatlabBridgeMsg::release_model() {
  clear_has_model();
  ::Model* temp = model_;
  model_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Model

// optional .FilePath mPath = 1;
inline bool Model::has_mpath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Model::set_has_mpath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Model::clear_has_mpath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Model::clear_mpath() {
  if (mpath_ != NULL) mpath_->::FilePath::Clear();
  clear_has_mpath();
}
inline const ::FilePath& Model::mpath() const {
  return mpath_ != NULL ? *mpath_ : *default_instance_->mpath_;
}
inline ::FilePath* Model::mutable_mpath() {
  set_has_mpath();
  if (mpath_ == NULL) mpath_ = new ::FilePath;
  return mpath_;
}
inline ::FilePath* Model::release_mpath() {
  clear_has_mpath();
  ::FilePath* temp = mpath_;
  mpath_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ServiceDefinition

// optional string key = 1 [default = ""];
inline bool ServiceDefinition::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ServiceDefinition::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ServiceDefinition::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ServiceDefinition::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& ServiceDefinition::key() const {
  return *key_;
}
inline void ServiceDefinition::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ServiceDefinition::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void ServiceDefinition::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDefinition::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* ServiceDefinition::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 2 [default = ""];
inline bool ServiceDefinition::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ServiceDefinition::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ServiceDefinition::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ServiceDefinition::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& ServiceDefinition::value() const {
  return *value_;
}
inline void ServiceDefinition::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ServiceDefinition::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void ServiceDefinition::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ServiceDefinition::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* ServiceDefinition::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Result

// optional .Labelable original = 1;
inline bool Result::has_original() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Result::set_has_original() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Result::clear_has_original() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Result::clear_original() {
  if (original_ != NULL) original_->::Labelable::Clear();
  clear_has_original();
}
inline const ::Labelable& Result::original() const {
  return original_ != NULL ? *original_ : *default_instance_->original_;
}
inline ::Labelable* Result::mutable_original() {
  set_has_original();
  if (original_ == NULL) original_ = new ::Labelable;
  return original_;
}
inline ::Labelable* Result::release_original() {
  clear_has_original();
  ::Labelable* temp = original_;
  original_ = NULL;
  return temp;
}

// optional .LabelableList foundLabels = 2;
inline bool Result::has_foundlabels() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Result::set_has_foundlabels() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Result::clear_has_foundlabels() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Result::clear_foundlabels() {
  if (foundlabels_ != NULL) foundlabels_->::LabelableList::Clear();
  clear_has_foundlabels();
}
inline const ::LabelableList& Result::foundlabels() const {
  return foundlabels_ != NULL ? *foundlabels_ : *default_instance_->foundlabels_;
}
inline ::LabelableList* Result::mutable_foundlabels() {
  set_has_foundlabels();
  if (foundlabels_ == NULL) foundlabels_ = new ::LabelableList;
  return foundlabels_;
}
inline ::LabelableList* Result::release_foundlabels() {
  clear_has_foundlabels();
  ::LabelableList* temp = foundlabels_;
  foundlabels_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// ResultList

// repeated .Result rslt = 1;
inline int ResultList::rslt_size() const {
  return rslt_.size();
}
inline void ResultList::clear_rslt() {
  rslt_.Clear();
}
inline const ::Result& ResultList::rslt(int index) const {
  return rslt_.Get(index);
}
inline ::Result* ResultList::mutable_rslt(int index) {
  return rslt_.Mutable(index);
}
inline ::Result* ResultList::add_rslt() {
  return rslt_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Result >&
ResultList::rslt() const {
  return rslt_;
}
inline ::google::protobuf::RepeatedPtrField< ::Result >*
ResultList::mutable_rslt() {
  return &rslt_;
}

// -------------------------------------------------------------------

// ResultSet

// optional .ResultList results = 1;
inline bool ResultSet::has_results() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResultSet::set_has_results() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResultSet::clear_has_results() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResultSet::clear_results() {
  if (results_ != NULL) results_->::ResultList::Clear();
  clear_has_results();
}
inline const ::ResultList& ResultSet::results() const {
  return results_ != NULL ? *results_ : *default_instance_->results_;
}
inline ::ResultList* ResultSet::mutable_results() {
  set_has_results();
  if (results_ == NULL) results_ = new ::ResultList;
  return results_;
}
inline ::ResultList* ResultSet::release_results() {
  clear_has_results();
  ::ResultList* temp = results_;
  results_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// DirectoryPath

// optional string relativePath = 1 [default = ""];
inline bool DirectoryPath::has_relativepath() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectoryPath::set_has_relativepath() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectoryPath::clear_has_relativepath() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectoryPath::clear_relativepath() {
  if (relativepath_ != &::google::protobuf::internal::kEmptyString) {
    relativepath_->clear();
  }
  clear_has_relativepath();
}
inline const ::std::string& DirectoryPath::relativepath() const {
  return *relativepath_;
}
inline void DirectoryPath::set_relativepath(const ::std::string& value) {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  relativepath_->assign(value);
}
inline void DirectoryPath::set_relativepath(const char* value) {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  relativepath_->assign(value);
}
inline void DirectoryPath::set_relativepath(const char* value, size_t size) {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  relativepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectoryPath::mutable_relativepath() {
  set_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    relativepath_ = new ::std::string;
  }
  return relativepath_;
}
inline ::std::string* DirectoryPath::release_relativepath() {
  clear_has_relativepath();
  if (relativepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relativepath_;
    relativepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// FilePath

// optional .DirectoryPath directory = 1;
inline bool FilePath::has_directory() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FilePath::set_has_directory() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FilePath::clear_has_directory() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FilePath::clear_directory() {
  if (directory_ != NULL) directory_->::DirectoryPath::Clear();
  clear_has_directory();
}
inline const ::DirectoryPath& FilePath::directory() const {
  return directory_ != NULL ? *directory_ : *default_instance_->directory_;
}
inline ::DirectoryPath* FilePath::mutable_directory() {
  set_has_directory();
  if (directory_ == NULL) directory_ = new ::DirectoryPath;
  return directory_;
}
inline ::DirectoryPath* FilePath::release_directory() {
  clear_has_directory();
  ::DirectoryPath* temp = directory_;
  directory_ = NULL;
  return temp;
}

// optional string filename = 2 [default = ""];
inline bool FilePath::has_filename() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FilePath::set_has_filename() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FilePath::clear_has_filename() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FilePath::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& FilePath::filename() const {
  return *filename_;
}
inline void FilePath::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FilePath::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void FilePath::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* FilePath::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* FilePath::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Substrate

// optional bool isImage = 1 [default = true];
inline bool Substrate::has_isimage() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Substrate::set_has_isimage() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Substrate::clear_has_isimage() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Substrate::clear_isimage() {
  isimage_ = true;
  clear_has_isimage();
}
inline bool Substrate::isimage() const {
  return isimage_;
}
inline void Substrate::set_isimage(bool value) {
  set_has_isimage();
  isimage_ = value;
}

// optional bool isVideo = 2 [default = false];
inline bool Substrate::has_isvideo() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Substrate::set_has_isvideo() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Substrate::clear_has_isvideo() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Substrate::clear_isvideo() {
  isvideo_ = false;
  clear_has_isvideo();
}
inline bool Substrate::isvideo() const {
  return isvideo_;
}
inline void Substrate::set_isvideo(bool value) {
  set_has_isvideo();
  isvideo_ = value;
}

// optional .FilePath path = 3;
inline bool Substrate::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Substrate::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Substrate::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Substrate::clear_path() {
  if (path_ != NULL) path_->::FilePath::Clear();
  clear_has_path();
}
inline const ::FilePath& Substrate::path() const {
  return path_ != NULL ? *path_ : *default_instance_->path_;
}
inline ::FilePath* Substrate::mutable_path() {
  set_has_path();
  if (path_ == NULL) path_ = new ::FilePath;
  return path_;
}
inline ::FilePath* Substrate::release_path() {
  clear_has_path();
  ::FilePath* temp = path_;
  path_ = NULL;
  return temp;
}

// optional int32 width = 4 [default = 0];
inline bool Substrate::has_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Substrate::set_has_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Substrate::clear_has_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Substrate::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline ::google::protobuf::int32 Substrate::width() const {
  return width_;
}
inline void Substrate::set_width(::google::protobuf::int32 value) {
  set_has_width();
  width_ = value;
}

// optional int32 height = 5 [default = 0];
inline bool Substrate::has_height() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Substrate::set_has_height() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Substrate::clear_has_height() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Substrate::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline ::google::protobuf::int32 Substrate::height() const {
  return height_;
}
inline void Substrate::set_height(::google::protobuf::int32 value) {
  set_has_height();
  height_ = value;
}

// -------------------------------------------------------------------

// Semantics

// optional string url = 1 [default = ""];
inline bool Semantics::has_url() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Semantics::set_has_url() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Semantics::clear_has_url() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Semantics::clear_url() {
  if (url_ != &::google::protobuf::internal::kEmptyString) {
    url_->clear();
  }
  clear_has_url();
}
inline const ::std::string& Semantics::url() const {
  return *url_;
}
inline void Semantics::set_url(const ::std::string& value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Semantics::set_url(const char* value) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(value);
}
inline void Semantics::set_url(const char* value, size_t size) {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  url_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Semantics::mutable_url() {
  set_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    url_ = new ::std::string;
  }
  return url_;
}
inline ::std::string* Semantics::release_url() {
  clear_has_url();
  if (url_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = url_;
    url_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// LabelProperties

// optional string key = 1 [default = ""];
inline bool LabelProperties::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LabelProperties::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LabelProperties::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LabelProperties::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& LabelProperties::key() const {
  return *key_;
}
inline void LabelProperties::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LabelProperties::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void LabelProperties::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelProperties::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* LabelProperties::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional string value = 2 [default = ""];
inline bool LabelProperties::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LabelProperties::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LabelProperties::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LabelProperties::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& LabelProperties::value() const {
  return *value_;
}
inline void LabelProperties::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LabelProperties::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void LabelProperties::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LabelProperties::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* LabelProperties::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// -------------------------------------------------------------------

// Label

// optional bool hasLabel = 1 [default = false];
inline bool Label::has_haslabel() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Label::set_has_haslabel() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Label::clear_has_haslabel() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Label::clear_haslabel() {
  haslabel_ = false;
  clear_has_haslabel();
}
inline bool Label::haslabel() const {
  return haslabel_;
}
inline void Label::set_haslabel(bool value) {
  set_has_haslabel();
  haslabel_ = value;
}

// optional string name = 2 [default = ""];
inline bool Label::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Label::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Label::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Label::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Label::name() const {
  return *name_;
}
inline void Label::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Label::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Label::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Label::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Label::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}

// optional .LabelProperties properties = 3;
inline bool Label::has_properties() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Label::set_has_properties() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Label::clear_has_properties() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Label::clear_properties() {
  if (properties_ != NULL) properties_->::LabelProperties::Clear();
  clear_has_properties();
}
inline const ::LabelProperties& Label::properties() const {
  return properties_ != NULL ? *properties_ : *default_instance_->properties_;
}
inline ::LabelProperties* Label::mutable_properties() {
  set_has_properties();
  if (properties_ == NULL) properties_ = new ::LabelProperties;
  return properties_;
}
inline ::LabelProperties* Label::release_properties() {
  clear_has_properties();
  ::LabelProperties* temp = properties_;
  properties_ = NULL;
  return temp;
}

// optional .Semantics semantix = 4;
inline bool Label::has_semantix() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Label::set_has_semantix() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Label::clear_has_semantix() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Label::clear_semantix() {
  if (semantix_ != NULL) semantix_->::Semantics::Clear();
  clear_has_semantix();
}
inline const ::Semantics& Label::semantix() const {
  return semantix_ != NULL ? *semantix_ : *default_instance_->semantix_;
}
inline ::Semantics* Label::mutable_semantix() {
  set_has_semantix();
  if (semantix_ == NULL) semantix_ = new ::Semantics;
  return semantix_;
}
inline ::Semantics* Label::release_semantix() {
  clear_has_semantix();
  ::Semantics* temp = semantix_;
  semantix_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// Labelable

// optional float confidence = 1 [default = 0];
inline bool Labelable::has_confidence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Labelable::set_has_confidence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Labelable::clear_has_confidence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Labelable::clear_confidence() {
  confidence_ = 0;
  clear_has_confidence();
}
inline float Labelable::confidence() const {
  return confidence_;
}
inline void Labelable::set_confidence(float value) {
  set_has_confidence();
  confidence_ = value;
}

// optional .Label lab = 2;
inline bool Labelable::has_lab() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Labelable::set_has_lab() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Labelable::clear_has_lab() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Labelable::clear_lab() {
  if (lab_ != NULL) lab_->::Label::Clear();
  clear_has_lab();
}
inline const ::Label& Labelable::lab() const {
  return lab_ != NULL ? *lab_ : *default_instance_->lab_;
}
inline ::Label* Labelable::mutable_lab() {
  set_has_lab();
  if (lab_ == NULL) lab_ = new ::Label;
  return lab_;
}
inline ::Label* Labelable::release_lab() {
  clear_has_lab();
  ::Label* temp = lab_;
  lab_ = NULL;
  return temp;
}

// optional .Substrate sub = 3;
inline bool Labelable::has_sub() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Labelable::set_has_sub() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Labelable::clear_has_sub() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Labelable::clear_sub() {
  if (sub_ != NULL) sub_->::Substrate::Clear();
  clear_has_sub();
}
inline const ::Substrate& Labelable::sub() const {
  return sub_ != NULL ? *sub_ : *default_instance_->sub_;
}
inline ::Substrate* Labelable::mutable_sub() {
  set_has_sub();
  if (sub_ == NULL) sub_ = new ::Substrate;
  return sub_;
}
inline ::Substrate* Labelable::release_sub() {
  clear_has_sub();
  ::Substrate* temp = sub_;
  sub_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// LabelableList

// repeated .Labelable labelable = 1;
inline int LabelableList::labelable_size() const {
  return labelable_.size();
}
inline void LabelableList::clear_labelable() {
  labelable_.Clear();
}
inline const ::Labelable& LabelableList::labelable(int index) const {
  return labelable_.Get(index);
}
inline ::Labelable* LabelableList::mutable_labelable(int index) {
  return labelable_.Mutable(index);
}
inline ::Labelable* LabelableList::add_labelable() {
  return labelable_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::Labelable >&
LabelableList::labelable() const {
  return labelable_;
}
inline ::google::protobuf::RepeatedPtrField< ::Labelable >*
LabelableList::mutable_labelable() {
  return &labelable_;
}

// -------------------------------------------------------------------

// Purpose

// optional .Purpose.PurposeType ptype = 1 [default = UNPURPOSED];
inline bool Purpose::has_ptype() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Purpose::set_has_ptype() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Purpose::clear_has_ptype() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Purpose::clear_ptype() {
  ptype_ = 0;
  clear_has_ptype();
}
inline ::Purpose_PurposeType Purpose::ptype() const {
  return static_cast< ::Purpose_PurposeType >(ptype_);
}
inline void Purpose::set_ptype(::Purpose_PurposeType value) {
  GOOGLE_DCHECK(::Purpose_PurposeType_IsValid(value));
  set_has_ptype();
  ptype_ = value;
}

// optional int32 classID = 2 [default = 0];
inline bool Purpose::has_classid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Purpose::set_has_classid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Purpose::clear_has_classid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Purpose::clear_classid() {
  classid_ = 0;
  clear_has_classid();
}
inline ::google::protobuf::int32 Purpose::classid() const {
  return classid_;
}
inline void Purpose::set_classid(::google::protobuf::int32 value) {
  set_has_classid();
  classid_ = value;
}

// -------------------------------------------------------------------

// PurposedLabelableSeq

// optional .Purpose pur = 1;
inline bool PurposedLabelableSeq::has_pur() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PurposedLabelableSeq::set_has_pur() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PurposedLabelableSeq::clear_has_pur() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PurposedLabelableSeq::clear_pur() {
  if (pur_ != NULL) pur_->::Purpose::Clear();
  clear_has_pur();
}
inline const ::Purpose& PurposedLabelableSeq::pur() const {
  return pur_ != NULL ? *pur_ : *default_instance_->pur_;
}
inline ::Purpose* PurposedLabelableSeq::mutable_pur() {
  set_has_pur();
  if (pur_ == NULL) pur_ = new ::Purpose;
  return pur_;
}
inline ::Purpose* PurposedLabelableSeq::release_pur() {
  clear_has_pur();
  ::Purpose* temp = pur_;
  pur_ = NULL;
  return temp;
}

// optional .LabelableList labeledArtifacts = 2;
inline bool PurposedLabelableSeq::has_labeledartifacts() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PurposedLabelableSeq::set_has_labeledartifacts() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PurposedLabelableSeq::clear_has_labeledartifacts() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PurposedLabelableSeq::clear_labeledartifacts() {
  if (labeledartifacts_ != NULL) labeledartifacts_->::LabelableList::Clear();
  clear_has_labeledartifacts();
}
inline const ::LabelableList& PurposedLabelableSeq::labeledartifacts() const {
  return labeledartifacts_ != NULL ? *labeledartifacts_ : *default_instance_->labeledartifacts_;
}
inline ::LabelableList* PurposedLabelableSeq::mutable_labeledartifacts() {
  set_has_labeledartifacts();
  if (labeledartifacts_ == NULL) labeledartifacts_ = new ::LabelableList;
  return labeledartifacts_;
}
inline ::LabelableList* PurposedLabelableSeq::release_labeledartifacts() {
  clear_has_labeledartifacts();
  ::LabelableList* temp = labeledartifacts_;
  labeledartifacts_ = NULL;
  return temp;
}

// -------------------------------------------------------------------

// PurposedListSequence

// repeated .PurposedLabelableSeq purlist = 1;
inline int PurposedListSequence::purlist_size() const {
  return purlist_.size();
}
inline void PurposedListSequence::clear_purlist() {
  purlist_.Clear();
}
inline const ::PurposedLabelableSeq& PurposedListSequence::purlist(int index) const {
  return purlist_.Get(index);
}
inline ::PurposedLabelableSeq* PurposedListSequence::mutable_purlist(int index) {
  return purlist_.Mutable(index);
}
inline ::PurposedLabelableSeq* PurposedListSequence::add_purlist() {
  return purlist_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::PurposedLabelableSeq >&
PurposedListSequence::purlist() const {
  return purlist_;
}
inline ::google::protobuf::RepeatedPtrField< ::PurposedLabelableSeq >*
PurposedListSequence::mutable_purlist() {
  return &purlist_;
}

// -------------------------------------------------------------------

// RunSet

// optional .PurposedListSequence purposedLists = 1;
inline bool RunSet::has_purposedlists() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RunSet::set_has_purposedlists() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RunSet::clear_has_purposedlists() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RunSet::clear_purposedlists() {
  if (purposedlists_ != NULL) purposedlists_->::PurposedListSequence::Clear();
  clear_has_purposedlists();
}
inline const ::PurposedListSequence& RunSet::purposedlists() const {
  return purposedlists_ != NULL ? *purposedlists_ : *default_instance_->purposedlists_;
}
inline ::PurposedListSequence* RunSet::mutable_purposedlists() {
  set_has_purposedlists();
  if (purposedlists_ == NULL) purposedlists_ = new ::PurposedListSequence;
  return purposedlists_;
}
inline ::PurposedListSequence* RunSet::release_purposedlists() {
  clear_has_purposedlists();
  ::PurposedListSequence* temp = purposedlists_;
  purposedlists_ = NULL;
  return temp;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::Purpose_PurposeType>() {
  return ::Purpose_PurposeType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_algorithms_2fmatlab_5fbridge_2fprotobuf_5fdefs_2eproto__INCLUDED
